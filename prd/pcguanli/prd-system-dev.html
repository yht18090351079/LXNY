<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>管理端PRD系统 - 农情遥感系统管理端产品需求文档 (开发版)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            color: #ffffff;
        }

        .prd-container {
            display: grid;
            grid-template-columns: 70% 30%;
            grid-template-rows: 70% 30%;
            height: 100vh;
            gap: 1px;
            padding: 0;
            background: #2a2a2a;
        }

        /* 左上角 - 内嵌页面区域 */
        .embedded-page {
            grid-column: 1;
            grid-row: 1;
            background: #000000;
            border: none;
            overflow: hidden;
            position: relative;
        }

        .embedded-page iframe {
            width: 1920px;
            height: 1080px;
            border: none;
            border-radius: 12px;
            transform-origin: top left;
            position: absolute;
            top: 10px;
            left: 0;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }



        /* 工具栏 */
        .toolbar {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 2000;
            display: flex;
            gap: 8px;
        }

        .toolbar-btn {
            background: rgba(42, 42, 42, 0.9);
            color: #ffffff;
            border: 1px solid #404040;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .toolbar-btn:hover {
            background: rgba(60, 60, 60, 0.9);
            border-color: #606060;
            transform: translateY(-1px);
        }

        .toolbar-btn:active {
            transform: translateY(0);
            background: rgba(80, 80, 80, 0.9);
        }

        .toolbar-btn.active {
            background: rgba(0, 168, 255, 0.9);
            border-color: #00a8ff;
        }

        /* 全屏状态样式 */
        .fullscreen-mode .prd-container {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }

        .fullscreen-mode .embedded-page {
            grid-column: 1;
            grid-row: 1;
        }

        .fullscreen-mode .annotation-panel,
        .fullscreen-mode .bottom-panels {
            display: none;
        }

        .fullscreen-mode .toolbar-btn.fullscreen-btn {
            background: rgba(220, 53, 69, 0.9);
            border-color: #dc3545;
        }

        /* 批注模式样式 */
        .annotation-mode .embedded-page {
            cursor: crosshair;
            position: relative;
        }

        .annotation-mode .embedded-page::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 168, 255, 0.1);
            pointer-events: none;
            border: 2px dashed #00a8ff;
            z-index: 1;
        }

        /* 批注模式下的iframe覆盖层 */
        .annotation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 2;
            cursor: crosshair;
        }

        /* 高亮样式 */
        .highlight-overlay {
            position: fixed;
            background: rgba(255, 193, 7, 0.3);
            border: 3px solid #ffc107;
            pointer-events: none;
            z-index: 1000;
            animation: highlight-pulse 1.5s infinite;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
        }

        @keyframes highlight-pulse {
            0% { 
                background: rgba(255, 193, 7, 0.2);
                border-color: #ffc107;
                transform: scale(1);
            }
            50% { 
                background: rgba(255, 193, 7, 0.4);
                border-color: #ffeb3b;
                transform: scale(1.02);
            }
            100% { 
                background: rgba(255, 193, 7, 0.2);
                border-color: #ffc107;
                transform: scale(1);
            }
        }

        /* 页面元素列表样式 */
        .element-list {
            margin-top: 12px;
        }

        .element-item {
            background: #404040;
            border: 1px solid #606060;
            padding: 8px 12px;
            margin-bottom: 6px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .element-item:hover {
            background: #505050;
            border-color: #00a8ff;
        }

        .element-item.active {
            background: rgba(0, 168, 255, 0.2);
            border-color: #00a8ff;
            color: #00a8ff;
        }

        .element-item .element-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .element-item .element-desc {
            font-size: 11px;
            color: #cccccc;
            opacity: 0.8;
        }

        /* 右侧 - 页面元素批注区域 */
        .annotation-panel {
            grid-column: 2;
            grid-row: 1 / 3;
            background: #2a2a2a;
            border: none;
            padding: 0;
            overflow: hidden;
            border-left: 1px solid #404040;
            display: flex;
            flex-direction: column;
        }

        .annotation-header {
            background: #1a1a1a;
            color: #ffffff;
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            border-bottom: 1px solid #404040;
            position: sticky;
            top: 0;
            z-index: 10;
            flex-shrink: 0;
        }

        .annotation-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
            font-size: 12px;
            color: #cccccc;
            line-height: 1.5;
            max-height: calc(100vh - 270px); /* 再减少50px高度，确保底部按钮更好显示 */
        }

        .annotation-item {
            background: #333333;
            border-left: 3px solid #00a8ff;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 0 4px 4px 0;
            transition: all 0.2s ease;
        }

        .annotation-item:hover {
            background: #3a3a3a;
            border-left-color: #20b8ff;
        }

        .annotation-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 13px;
        }

        /* Markdown样式支持 */
        .annotation-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .annotation-content li {
            margin: 4px 0;
            list-style-type: disc;
        }

        .annotation-content li.nested {
            margin-left: 15px;
            list-style-type: circle;
            color: #aaaaaa;
        }

        .annotation-content strong {
            color: #ffffff;
            font-weight: 600;
        }

        .annotation-content code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }

        .annotation-content h3, .annotation-content h4 {
            color: #00a8ff;
            margin: 12px 0 6px 0;
            font-size: 13px;
        }

        .annotation-content p {
            margin: 6px 0;
        }

        /* 长内容批注样式优化 */
        .annotation-content div[style*="margin-top: 8px"] {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 8px;
            /* 为滚动条预留空间 */
        }

        /* 批注内容区域的滚动条美化 */
        .annotation-content div[style*="margin-top: 8px"]::-webkit-scrollbar {
            width: 6px;
        }

        .annotation-content div[style*="margin-top: 8px"]::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 3px;
        }

        .annotation-content div[style*="margin-top: 8px"]::-webkit-scrollbar-thumb {
            background: #555555;
            border-radius: 3px;
        }

        .annotation-content div[style*="margin-top: 8px"]::-webkit-scrollbar-thumb:hover {
            background: #666666;
        }

        /* 底部三栏区域 */
        .bottom-panels {
            grid-column: 1;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1px;
            background: #2a2a2a;
        }

        .panel {
            background: #2a2a2a;
            border: none;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel:not(:first-child) {
            border-left: 1px solid #404040;
        }

        .panel-header {
            background: #1a1a1a;
            color: #ffffff;
            padding: 12px 16px;
            font-weight: 600;
            font-size: 13px;
            border-bottom: 1px solid #404040;
            position: sticky;
            top: 0;
            z-index: 10;
            flex-shrink: 0;
        }

        .panel-content {
            font-size: 12px;
            line-height: 1.6;
            color: #cccccc;
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .panel-content h4 {
            color: #ffffff;
            font-size: 13px;
            margin: 12px 0 8px 0;
            font-weight: 600;
        }

        .panel-content ul {
            margin: 8px 0;
            padding-left: 16px;
        }

        .panel-content li {
            margin-bottom: 4px;
            color: #cccccc;
        }

        .panel-content strong {
            color: #ffffff;
        }

        .panel-content code {
            background: #404040;
            color: #00a8ff;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .nav-button {
            background: #404040;
            color: #ffffff;
            border: 1px solid #606060;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            margin: 4px;
            transition: all 0.2s ease;
        }

        .nav-button:hover {
            background: #505050;
            border-color: #00a8ff;
            color: #00a8ff;
        }

        .nav-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #333333;
            border-color: #404040;
            color: #666666;
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        /* 响应式设计 */
        @media (max-width: 1200px) {
            .prd-container {
                grid-template-columns: 65% 35%;
            }
        }

        @media (max-width: 768px) {
            .prd-container {
                grid-template-columns: 1fr;
                grid-template-rows: 50% 25% 25%;
            }
            
            .annotation-panel {
                grid-column: 1;
                grid-row: 2;
            }
            
            .bottom-panels {
                grid-row: 3;
            }
        }

        /* 动画效果 */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .panel, .annotation-panel, .embedded-page {
            animation: fadeInUp 0.6s ease-out;
        }

        .annotation-panel {
            animation-delay: 0.1s;
        }

        .bottom-panels .panel:nth-child(1) {
            animation-delay: 0.2s;
        }

        .bottom-panels .panel:nth-child(2) {
            animation-delay: 0.3s;
        }

        .bottom-panels .panel:nth-child(3) {
            animation-delay: 0.4s;
        }
    </style>
</head>
<body>
    <!-- 工具栏 -->
    <div class="toolbar" id="mainToolbar">
        <button class="toolbar-btn annotation-btn" id="annotationBtn" onclick="toggleAnnotationMode()" title="批注模式">
            <span id="annotationIcon">📝</span>
        </button>
        <button class="toolbar-btn fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()" title="全屏显示">
            <span id="fullscreenIcon">⛶</span>
        </button>
        <button class="toolbar-btn debug-btn" id="debugBtn" onclick="showDebugMenu()" title="调试工具">
            <span>🔧</span>
        </button>
    </div>

    <div class="prd-container">
        <!-- 左上角 - 内嵌页面区域 (70%) -->
        <div class="embedded-page">
            <iframe id="embeddedFrame" src="../../大屏原型/index.html" title="农情遥感系统大屏"></iframe>
        </div>

        <!-- 右侧 - 页面元素批注区域 -->
        <div class="annotation-panel">
            <div class="annotation-header">
                📝 页面元素批注
            </div>
            <div id="annotationContent">
                <!-- 批注内容将通过JavaScript动态加载 -->
            </div>
        </div>

        <!-- 底部三栏区域 -->
        <div class="bottom-panels">
            <!-- 第一栏 - 全局说明 -->
            <div class="panel">
                <div class="panel-header">🌐 全局说明</div>
                <div class="panel-content" id="globalDescription">
                    <p>正在加载全局说明...</p>
                </div>
            </div>

            <!-- 第二栏 - 页面说明 -->
            <div class="panel">
                <div class="panel-header">📄 页面说明</div>
                <div class="panel-content" id="pageDescription">
                    <!-- 页面说明内容将通过JavaScript动态加载 -->
                </div>
            </div>

            <!-- 第三栏 - 页面元素清单 -->
            <div class="panel">
                <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center; position: relative;">
                    <span>📋 页面元素清单</span>
                    <!-- 批注导航按钮 -->
                    <div id="annotationNavigation" style="display: none;">
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <button id="prevAnnotationBtn" onclick="navigateToPreviousAnnotation()" 
                                    style="background: #667eea; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;"
                                    title="上一批注 (← 或 J 键)">
                                ←
                            </button>
                            <div id="annotationCounter" style="font-size: 9px; color: #ccc; white-space: nowrap;">
                                1/5
                            </div>
                            <button id="nextAnnotationBtn" onclick="navigateToNextAnnotation()" 
                                    style="background: #667eea; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;"
                                    title="下一批注 (→ 或 K 键)">
                                →
                            </button>
                        </div>
                    </div>
                </div>
                <div class="panel-content">

                      <div class="element-list" id="elementList">
                          <!-- 页面元素清单将通过JavaScript动态生成 -->
                      </div>

                    <h4>系统状态</h4>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(103, 126, 234, 0.1); border-radius: 6px; font-size: 11px;">
                        <div>🟢 系统运行正常</div>
                        <div>📡 数据连接稳定</div>
                        <div>📝 批注数据: <span id="annotationStatus">加载中...</span></div>
                        <div>⏰ 最后更新: <span id="lastUpdate"></span></div>
                        <div style="margin-top: 4px; padding-top: 4px; border-top: 1px solid rgba(255,255,255,0.1); color: #ffc107;">
                            💡 数据源: prd-docs/annotations.json
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== 环境模式配置 ==========
        
        // 强制设置为开发模式（开发版本）
        const APP_MODE = 'development';
        
        function detectAppMode() {
            // 开发版本始终返回开发模式
            return 'development';
            // 检测方式1: URL参数
            const urlParams = new URLSearchParams(window.location.search);
            const modeParam = urlParams.get('mode');
            if (modeParam === 'dev' || modeParam === 'development') {
                return 'development';
            }
            if (modeParam === 'prod' || modeParam === 'production') {
                return 'production';
            }
            
            // 检测方式2: 域名判断
            const hostname = window.location.hostname;
            if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('dev') || hostname.includes('test')) {
                return 'development';
            }
            
            // 检测方式3: 后端API可用性检测
            if (typeof window.PRD_API_BASE_URL !== 'undefined') {
                return 'development';
            }
            
            // 默认线上模式
            return 'production';
        }
        
        // 环境配置
        const ENV_CONFIG = {
            development: {
                name: '开发模式',
                icon: '🛠️',
                allowAnnotation: true,
                allowEdit: true,
                enableRealTimeSync: true,
                apiBaseUrl: window.PRD_API_BASE_URL || 'http://localhost:3000/api',
                debugMode: true,
                showDebugTools: true
            },
            production: {
                name: '线上模式',
                icon: '🌐',
                allowAnnotation: false,
                allowEdit: false,
                enableRealTimeSync: false,
                apiBaseUrl: null,
                debugMode: false,
                showDebugTools: false
            }
        };
        
        // 当前环境配置
        const CURRENT_ENV = ENV_CONFIG[APP_MODE];
        
        console.log(`🌍 当前运行模式: ${CURRENT_ENV.name} (${APP_MODE})`);
        
        // ========== API 集成 ==========
        
        // 后端API集成类
        class PRDApiClient {
            constructor() {
                this.baseUrl = CURRENT_ENV.apiBaseUrl;
                this.enabled = CURRENT_ENV.enableRealTimeSync && this.baseUrl;
                
                if (this.enabled) {
                    console.log('🔗 API客户端已启用:', this.baseUrl);
                } else {
                    console.log('📴 API客户端已禁用');
                }
            }
            
            // 检查API可用性
            async checkConnection() {
                if (!this.enabled) return false;
                
                try {
                    const response = await fetch(`${this.baseUrl}/health`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    return response.ok;
                } catch (error) {
                    console.warn('API连接检查失败:', error);
                    return false;
                }
            }
            
            // 加载批注数据
            async loadAnnotations() {
                if (!this.enabled) {
                    // 本地模式：从文件加载
                    return this.loadAnnotationsFromFile();
                }
                
                try {
                    const response = await fetch(`${this.baseUrl}/annotations`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('📥 从API加载批注数据成功');
                        return data;
                    } else {
                        throw new Error(`API请求失败: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('API加载失败，回退到本地文件:', error);
                    return this.loadAnnotationsFromFile();
                }
            }
            
            // 从本地文件加载批注数据
            async loadAnnotationsFromFile() {
                try {
                    const timestamp = new Date().getTime() + Math.random();
                    const response = await fetch(`prd-docs/annotations.json?t=${timestamp}`, {
                        method: 'GET',
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    
                    if (response.ok) {
                        return await response.json();
                    } else {
                        return {};
                    }
                } catch (error) {
                    console.warn('本地文件加载失败:', error);
                    return {};
                }
            }
            
            // 保存批注数据
            async saveAnnotations(annotations) {
                if (!this.enabled) {
                    // 本地模式：下载文件
                    this.downloadAnnotations(annotations);
                    return true;
                }
                
                try {
                    const response = await fetch(`${this.baseUrl}/annotations`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(annotations)
                    });
                    
                    if (response.ok) {
                        console.log('📤 批注数据已保存到服务器');
                        return true;
                    } else {
                        throw new Error(`保存失败: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('API保存失败，回退到本地下载:', error);
                    this.downloadAnnotations(annotations);
                    return false;
                }
            }
            
            // 下载批注文件
            downloadAnnotations(annotations) {
                const cleanedAnnotations = cleanAnnotationsForSave(annotations);
                const dataStr = JSON.stringify(cleanedAnnotations, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                link.download = `annotations-${timestamp}.json`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                console.log('✅ 批注数据已导出:', `annotations-${timestamp}.json`);
            }
            
            // 增量更新单个批注
            async updateAnnotation(pageKey, elementId, annotation, action = 'update') {
                if (!this.enabled) return false;
                
                try {
                    const response = await fetch(`${this.baseUrl}/annotations/update`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            pageKey, 
                            elementId, 
                            annotation, 
                            action,
                            timestamp: new Date().toISOString() 
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log(`✅ 增量更新成功: ${result.operation} - ${elementId}`);
                        return result;
                    } else {
                        throw new Error(`增量更新失败: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('增量更新失败:', error);
                    return false;
                }
            }
            
            // 实时同步批注（广播用）
            async syncAnnotation(annotation, action = 'create') {
                if (!this.enabled) return false;
                
                try {
                    const response = await fetch(`${this.baseUrl}/annotations/sync`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ annotation, action, timestamp: new Date().toISOString() })
                    });
                    
                    return response.ok;
                } catch (error) {
                    console.warn('实时同步失败:', error);
                    return false;
                }
            }
        }
        
        // 全局API客户端实例
        const apiClient = new PRDApiClient();
        
        // ========== 权限控制 ==========
        
        // 权限检查函数
        function checkPermission(action) {
            switch (action) {
                case 'annotation':
                    return CURRENT_ENV.allowAnnotation;
                case 'edit':
                    return CURRENT_ENV.allowEdit;
                case 'debug':
                    return CURRENT_ENV.showDebugTools;
                default:
                    return true;
            }
        }
        
        // 显示权限提示
        function showPermissionDenied(action) {
            let message = '';
            switch (action) {
                case 'annotation':
                    message = '当前为线上模式，不允许添加批注。如需编辑，请切换到开发环境。';
                    break;
                case 'edit':
                    message = '当前为线上模式，不允许编辑内容。';
                    break;
                default:
                    message = '当前模式下不允许此操作。';
            }
            
            alert(`🚫 权限不足\n\n${message}\n\n当前模式: ${CURRENT_ENV.icon} ${CURRENT_ENV.name}`);
        }
        
        // ========== 模式指示器 ==========
        
        // 创建模式指示器
        function createModeIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'mode-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 12px;
                left: 12px;
                z-index: 3000;
                background: ${APP_MODE === 'development' ? 'rgba(76, 175, 80, 0.9)' : 'rgba(33, 150, 243, 0.9)'};
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 600;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            
            indicator.innerHTML = `
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 14px;">${CURRENT_ENV.icon}</span>
                    <span>${CURRENT_ENV.name}</span>
                    ${CURRENT_ENV.debugMode ? '<span style="font-size: 10px; opacity: 0.8;">DEBUG</span>' : ''}
                </div>
            `;
            
            indicator.addEventListener('click', showModeInfo);
            indicator.addEventListener('mouseenter', () => {
                indicator.style.transform = 'translateY(-1px)';
                indicator.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
            });
            indicator.addEventListener('mouseleave', () => {
                indicator.style.transform = 'translateY(0)';
                indicator.style.boxShadow = 'none';
            });
            
            document.body.appendChild(indicator);
        }
        
        // 显示模式信息
        function showModeInfo() {
            const info = `
🌍 当前运行模式: ${CURRENT_ENV.icon} ${CURRENT_ENV.name}

📋 功能权限:
• 查看批注: ✅ 允许
• 添加批注: ${CURRENT_ENV.allowAnnotation ? '✅ 允许' : '❌ 禁止'}
• 编辑内容: ${CURRENT_ENV.allowEdit ? '✅ 允许' : '❌ 禁止'}
• 调试工具: ${CURRENT_ENV.showDebugTools ? '✅ 启用' : '❌ 禁用'}

🔗 数据源:
• API地址: ${CURRENT_ENV.apiBaseUrl || '本地文件'}
• 实时同步: ${CURRENT_ENV.enableRealTimeSync ? '✅ 启用' : '❌ 禁用'}

💡 模式切换:
• 开发模式: 添加 ?mode=dev 参数
• 线上模式: 添加 ?mode=prod 参数
            `.trim();
            
            alert(info);
        }

        // 功能模块配置数据 - 基于功能切换栏的data-function属性
        const functionConfigs = {
            'crop-distribution': {
                title: '作物分布监测',
                mdFile: '作物分布监测.md',
                annotations: [
                    {
                        title: '🗺️ 三维地图视图',
                        content: '基于Cesium.js的三维地球，支持多种地图底图切换，可进行缩放、旋转、倾斜等操作。'
                    },
                    {
                        title: '📊 右侧数据面板',
                        content: '包含作物面积环形图、大棚统计卡片、区域面积汇总等数据可视化组件。'
                    },
                    {
                        title: '📈 左侧分析面板',
                        content: '展示种植结构对比柱状图、作物轮作桑基图、数据更新状态等分析图表。'
                    },
                    {
                        title: '⚙️ 功能导航栏',
                        content: `底部导航栏提供不同功能模块的快速切换，包括作物分布、灾害监测等。

- **主功能按钮**: 5个单选按钮，切换不同页面功能
  - 🌾 作物分布 (当前页面)
  - 📊 长势分析 (growth-analysis.html)
  - 📈 产量预估 (yield-estimation.html)
  - 🌤️ 气象监测 (weather-monitoring.html)
  - ⚠️ 灾害定损 (disaster-monitoring.html)`
                    }
                ]
            },
            'growth-analysis': {
                title: '长势分析功能',
                mdFile: '长势分析功能.md',
                annotations: [
                    {
                        title: '📊 长势等级图表',
                        content: '以饼图或柱状图形式展示不同长势等级的面积分布。'
                    },
                    {
                        title: '🗺️ 长势空间分布',
                        content: '在地图上用不同颜色表示各区域的作物长势等级。'
                    },
                    {
                        title: '📈 植被指数曲线',
                        content: '显示NDVI等植被指数的时间序列变化曲线。'
                    },
                    {
                        title: '🔍 发育期标注',
                        content: '在时间轴上标注作物的关键发育期节点。'
                    }
                ]
            },
            'yield-estimation': {
                title: '产量预估功能',
                mdFile: '产量预估功能.md',
                annotations: [
                    {
                        title: '📊 产量预估图表',
                        content: '以柱状图、折线图等形式展示各作物的产量预估结果和历史对比。'
                    },
                    {
                        title: '🗺️ 产量空间分布',
                        content: '在地图上以色彩渐变方式显示不同区域的产量预估水平。'
                    },
                    {
                        title: '📈 生长监测曲线',
                        content: '显示作物生长季内NDVI等植被指数的变化曲线。'
                    },
                    {
                        title: '🎯 精度验证面板',
                        content: '展示产量预估模型的精度指标和验证结果。'
                    }
                ]
            },
            'weather-monitoring': {
                title: '气象监测功能',
                mdFile: '气象监测功能.md',
                annotations: [
                    {
                        title: '🌡️ 气象要素显示',
                        content: '实时显示温度、湿度、气压、风速风向等基本气象要素数据。'
                    },
                    {
                        title: '🌧️ 降水分布图',
                        content: '以等值线或色彩填充方式显示降水分布，支持历史回放功能。'
                    },
                    {
                        title: '📈 气象趋势图',
                        content: '展示气象要素的时间变化趋势，支持多要素同时显示。'
                    },
                    {
                        title: '⚠️ 预警信息面板',
                        content: '显示当前生效的气象预警信息，包括预警等级和影响区域。'
                    }
                ]
            },
            'disaster-monitoring': {
                title: '灾害定损功能',
                mdFile: '灾害定损功能.md',
                annotations: [
                    {
                        title: '🌪️ 灾害类型识别',
                        content: '系统可自动识别洪涝、干旱、冰雹、病虫害等多种农业灾害类型。'
                    },
                    {
                        title: '📍 受灾区域标注',
                        content: '在地图上用不同颜色标注受灾区域，支持点击查看详细灾害信息。'
                    },
                    {
                        title: '📊 损失统计图表',
                        content: '提供受灾面积统计、经济损失评估、灾害等级分布等数据图表。'
                    },
                    {
                        title: '🔍 影像对比工具',
                        content: '支持灾前灾后遥感影像对比，直观展示灾害影响程度。'
                    }
                ]
            },
            'device-monitoring': {
                title: '设备监控功能',
                mdFile: '设备监控功能.md',
                annotations: [
                    {
                        title: '📱 设备状态监控',
                        content: '实时监控各类农业物联网设备的运行状态和数据传输情况。'
                    },
                    {
                        title: '📊 设备数据统计',
                        content: '统计设备数据采集量、在线率、故障率等关键指标。'
                    },
                    {
                        title: '⚠️ 设备异常预警',
                        content: '设备离线、数据异常、设备故障等情况的及时预警提醒。'
                    },
                    {
                        title: '🔧 设备管理工具',
                        content: '提供设备配置、参数设置、远程控制等管理功能。'
                    }
                ]
            },
            'crop-selection': {
                title: '作物选择功能',
                mdFile: '作物选择功能.md',
                annotations: [
                    {
                        title: '🌾 作物类型筛选',
                        content: '支持按作物类型（小麦、玉米、辣椒等）进行地图显示筛选。'
                    },
                    {
                        title: '📅 生长期筛选',
                        content: '按作物不同生长发育期进行数据筛选和分析展示。'
                    },
                    {
                        title: '🗺️ 空间范围选择',
                        content: '支持框选、圆选、多边形选择等多种空间范围选择方式。'
                    },
                    {
                        title: '📊 条件组合筛选',
                        content: '支持多条件组合筛选，实现精准的数据查询和分析。'
                    }
                ]
            }
        };

        // 页面配置数据 - 兼容原有的页面切换逻辑
        const pageConfigs = {
            'index.html': functionConfigs['crop-distribution'],
            'disaster-monitoring.html': functionConfigs['disaster-monitoring'],
            'weather-monitoring.html': functionConfigs['weather-monitoring'],
            'yield-estimation.html': functionConfigs['yield-estimation'],
            'growth-analysis.html': functionConfigs['growth-analysis']
        };

        // 页面列表 - 管理端原型主要页面
        const pages = ['index.html'];
        let currentPageIndex = 0;
        let currentFunction = 'crop-distribution'; // 当前选中的功能
        let isFullscreen = false; // 全屏状态
        let isAnnotationMode = false; // 批注模式状态
        let currentAnnotations = {}; // 当前页面的批注数据
        let selectedElementId = null; // 当前选中的元素ID
        let pageElements = {}; // 抓取到的页面元素
        
        // 批注导航相关变量
        let currentPageAnnotationList = []; // 当前页面的批注列表
        let currentAnnotationIndex = 0; // 当前选中的批注索引

        // 智能检测并设置iframe路径
        function setupSmartIframePath() {
            const iframe = document.getElementById('embeddedFrame');
            const currentUrl = window.location.href;
            
            let targetPath;
            
            if (currentUrl.includes('localhost:3000') || currentUrl.includes('127.0.0.1:3000')) {
                // 通过API服务器访问
                targetPath = '/管理端原型/index.html';
                console.log('🌐 检测到API服务器环境，使用服务器路径');
            } else if (currentUrl.includes('127.0.0.1:5501') || currentUrl.includes('localhost:5501')) {
                // 通过Live Server访问
                targetPath = '/管理端原型/index.html';
                console.log('🌐 检测到Live Server环境，使用服务器路径');
            } else {
                // 直接打开文件
                targetPath = '../../管理端原型/index.html';
                console.log('📁 检测到本地文件访问，使用相对路径');
            }
            
            iframe.src = targetPath;
            console.log('🎯 iframe路径已设置为:', targetPath);
        }

        // 初始化页面
        async function initializePage() {
            console.log('=== 页面初始化开始 ===');
            
            // 步骤0: 智能设置iframe路径
            console.log('步骤0: 智能设置iframe路径');
            setupSmartIframePath();
            
            // 步骤1: 创建模式指示器和UI适配
            console.log('步骤1: 环境配置和UI适配');
            createModeIndicator();
            adaptUIForCurrentMode();
            
            // 检查API连接（开发模式下）
            if (CURRENT_ENV.enableRealTimeSync) {
                console.log('步骤1.5: 检查API连接');
                const apiConnected = await apiClient.checkConnection();
                updateConnectionStatus(apiConnected);
            }
            
            // 首先加载批注数据
            console.log('步骤2: 加载批注数据');
            await loadAnnotations();
            
            // 然后更新页面内容
            console.log('步骤3: 更新页面内容');
            await updatePageContent();

            console.log('步骤4: 更新时间戳');
            updateLastUpdateTime();
            
            console.log('步骤5: 加载全局说明');
            
            console.log('步骤6: 启动页面状态监听');
            startPageStateMonitoring();
            
            console.log('步骤7: 设置键盘快捷键');
            setupKeyboardShortcuts();
            await loadGlobalDescription();
            
            // 计算并应用iframe缩放
            console.log('步骤8: 计算iframe缩放');
            calculateIframeScale();
            
            // 设置iframe加载完成后的监听
            console.log('步骤9: 设置iframe监听');
            setupIframeListener();
            
            // 延迟更新元素清单，确保所有数据都已加载
            setTimeout(() => {
                console.log('步骤10: 延迟更新元素清单');
                updateElementList();
            }, 2000);
            
            // 每分钟更新时间
            setInterval(updateLastUpdateTime, 60000);
            
            // 监听窗口大小变化
            window.addEventListener('resize', calculateIframeScale);
        }
        
        // 根据当前模式适配UI
        function adaptUIForCurrentMode() {
            console.log('🎨 适配UI界面为', CURRENT_ENV.name);
            
            // 获取UI元素
            const annotationBtn = document.getElementById('annotationBtn');
            const debugBtn = document.getElementById('debugBtn');
            
            // 线上模式隐藏/禁用批注按钮
            if (!CURRENT_ENV.allowAnnotation && annotationBtn) {
                annotationBtn.style.display = 'none';
                console.log('🚫 已隐藏批注按钮（线上模式）');
            }
            
            // 线上模式隐藏调试按钮
            if (!CURRENT_ENV.showDebugTools && debugBtn) {
                debugBtn.style.display = 'none';
                console.log('🚫 已隐藏调试按钮（线上模式）');
            }
            
            // 修改页面标题
            document.title = `智能化PRD系统 - ${CURRENT_ENV.name}`;
            
            // 在系统状态中显示模式信息
            updateSystemStatus();
        }
        
        // 更新连接状态
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('annotationStatus');
            if (statusElement && CURRENT_ENV.enableRealTimeSync) {
                if (connected) {
                    statusElement.textContent = '已连接API服务器';
                    statusElement.style.color = '#4CAF50';
                } else {
                    statusElement.textContent = 'API连接失败，使用本地模式';
                    statusElement.style.color = '#ff9800';
                }
            }
        }
        
        // 更新系统状态显示
        function updateSystemStatus() {
            // 在系统状态区域添加模式信息
            const systemStatus = document.querySelector('#elementList').parentElement;
            if (systemStatus) {
                const existingModeInfo = systemStatus.querySelector('#mode-status');
                if (existingModeInfo) {
                    existingModeInfo.remove();
                }
                
                const modeInfo = document.createElement('div');
                modeInfo.id = 'mode-status';
                modeInfo.style.cssText = `
                    margin-top: 12px; 
                    padding: 8px; 
                    background: ${APP_MODE === 'development' ? 'rgba(76, 175, 80, 0.1)' : 'rgba(33, 150, 243, 0.1)'}; 
                    border-radius: 6px; 
                    font-size: 11px;
                    border-left: 3px solid ${APP_MODE === 'development' ? '#4CAF50' : '#2196F3'};
                `;
                
                // 获取当前页面信息
                const detectedFunction = detectCurrentFunction();
                const functionTitle = functionConfigs[detectedFunction]?.title || detectedFunction;
                const currentPageKey = getCurrentPageKey();
                const hasAnnotations = currentAnnotations[currentPageKey] && Object.keys(currentAnnotations[currentPageKey]).length > 0;
                
                modeInfo.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 4px;">
                        ${CURRENT_ENV.icon} 当前模式: ${CURRENT_ENV.name}
                    </div>
                    <div>• 当前页面: 🎯 ${functionTitle}</div>
                    <div>• 页面批注: ${hasAnnotations ? '✅ 有数据' : '📝 待添加'}</div>
                    <div>• 批注功能: ${CURRENT_ENV.allowAnnotation ? '✅ 启用' : '❌ 禁用'}</div>
                    <div>• 编辑功能: ${CURRENT_ENV.allowEdit ? '✅ 启用' : '❌ 禁用'}</div>
                    <div>• 数据同步: ${CURRENT_ENV.enableRealTimeSync ? '✅ 实时' : '📁 本地'}</div>
                `;
                
                systemStatus.appendChild(modeInfo);
            }
        }
        
        // 显示调试菜单
        function showDebugMenu() {
            if (!checkPermission('debug')) {
                showPermissionDenied('debug');
                return;
            }
            
            const debugMenu = `
🔧 调试工具菜单

请选择操作:
1. 系统诊断
2. 测试所有批注
3. 查看元素签名
4. 批注数据修复
5. 强制刷新数据
6. 测试API连接
7. 导出调试信息

输入选项数字 (1-7):
            `.trim();
            
            const choice = prompt(debugMenu);
            
            switch (choice) {
                case '1':
                    comprehensiveDiagnosis();
                    break;
                case '2':
                    testAllAnnotations();
                    break;
                case '3':
                    showElementSignatures();
                    break;
                case '4':
                    validateAndFixAnnotations();
                    break;
                case '5':
                    forceRefreshAnnotations();
                    break;
                case '6':
                    testApiConnection();
                    break;
                case '7':
                    exportDebugInfo();
                    break;
                default:
                    if (choice !== null) {
                        alert('无效选项，请输入 1-7 之间的数字');
                    }
            }
        }
        
        // 测试API连接
        async function testApiConnection() {
            if (!CURRENT_ENV.enableRealTimeSync) {
                alert('当前模式下API功能未启用');
                return;
            }
            
            console.log('🔗 测试API连接...');
            const connected = await apiClient.checkConnection();
            
            if (connected) {
                alert('✅ API连接测试成功！\n服务器响应正常。');
            } else {
                alert('❌ API连接测试失败！\n请检查:\n1. 服务器是否启动\n2. 网络连接\n3. API地址配置');
            }
        }
        
        // 导出调试信息
        function exportDebugInfo() {
            const debugInfo = {
                timestamp: new Date().toISOString(),
                mode: APP_MODE,
                environment: CURRENT_ENV,
                annotations: currentAnnotations,
                pageElements: pageElements,
                system: {
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    viewport: {
                        width: window.innerWidth,
                        height: window.innerHeight
                    }
                }
            };
            
            const dataStr = JSON.stringify(debugInfo, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `prd-debug-${timestamp}.json`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert('🔧 调试信息已导出到文件');
        }

        // 设置iframe内容监听 - 改进版
        function setupIframeListener() {
            const iframe = document.getElementById('embeddedFrame');
            
            iframe.onload = function() {
                console.log('=== iframe加载完成 ===');
                
                // 重新计算缩放
                setTimeout(calculateIframeScale, 300);
                
                // 尝试多种方式访问iframe内容
                let iframeAccessible = false;
                
                try {
                    // 方法1: 直接访问contentDocument
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc && iframeDoc.body) {
                        console.log('✅ iframe直接访问成功');
                        iframeAccessible = true;
                        setupIframeContent(iframeDoc);
                        
                        // 检测当前功能状态并更新
                        setTimeout(() => {
                            detectCurrentFunction();
                        }, 1000);
                    }
                } catch (error) {
                    console.log('❌ iframe直接访问失败:', error.message);
                }
                
                // 方法2: postMessage通信
                if (!iframeAccessible) {
                    console.log('尝试postMessage通信...');
                    setupPostMessageCommunication(iframe);
                }
                
                // 方法3: 坐标映射高亮（备用方案）
                if (!iframeAccessible) {
                    console.log('使用坐标映射备用方案');
                    setupCoordinateMapping();
                }
                
                // 延迟重试访问
                    setTimeout(() => {
                    if (!iframeAccessible) {
                        console.log('延迟重试iframe访问...');
                        try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                            if (iframeDoc && iframeDoc.body) {
                                console.log('✅ 延迟访问成功');
                                setupIframeContent(iframeDoc);
                            }
                        } catch (e) {
                            console.log('❌ 延迟访问仍然失败');
                        }
                    }
                }, 2000);
            };
        }
        
        // 设置iframe内容（当可以访问时）
        function setupIframeContent(iframeDoc) {
            try {
                console.log('设置iframe内容交互...');
                
                            // 监听功能切换按钮点击
                            const functionButtons = iframeDoc.querySelectorAll('.main-switch-btn, .overlay-switch-btn');
                console.log('找到功能按钮数量:', functionButtons.length);
                            
                            functionButtons.forEach(button => {
                                button.addEventListener('click', async function() {
                                    const functionName = this.getAttribute('data-function');
                        console.log('功能切换:', functionName);
                                    if (functionName && functionConfigs[functionName]) {
                                        currentFunction = functionName;
                                        await updatePageContentByFunction(functionName);
                                    }
                                });
                            });

                            // 检测当前激活的功能按钮
                            const activeButton = iframeDoc.querySelector('.main-switch-btn.active, .overlay-switch-btn.active');
                            if (activeButton) {
                                const functionName = activeButton.getAttribute('data-function');
                                if (functionName && functionConfigs[functionName]) {
                                    currentFunction = functionName;
                                    updatePageContentByFunction(functionName);
                                }
                            }

                            // 抓取页面元素
                            extractPageElements(iframeDoc);
                            
                            // 如果已经是批注模式，重新设置覆盖层
                            if (isAnnotationMode) {
                                setTimeout(() => {
                                    setupAnnotationOverlay();
                                }, 500);
                            }
                
                console.log('✅ iframe内容设置完成');
                
            } catch (error) {
                console.log('❌ iframe内容设置失败:', error);
            }
        }
        
        // 设置postMessage通信
        function setupPostMessageCommunication(iframe) {
            console.log('设置postMessage通信...');
            
            // 监听来自iframe的消息
            window.addEventListener('message', function(event) {
                // 安全检查
                if (event.source !== iframe.contentWindow) return;
                
                const data = event.data;
                console.log('收到iframe消息:', data);
                
                if (data.type === 'elementInfo') {
                    // 接收元素信息
                    handleElementInfo(data.elements);
                } else if (data.type === 'functionChange') {
                    // 功能切换
                    currentFunction = data.function;
                    updatePageContentByFunction(data.function);
                }
            });
            
            // 向iframe发送初始化消息
            setTimeout(() => {
                try {
                    iframe.contentWindow.postMessage({
                        type: 'init',
                        message: '批注系统初始化'
                    }, '*');
                } catch (e) {
                    console.log('postMessage发送失败:', e);
                        }
                    }, 1000);
        }
        
        // 设置坐标映射（备用方案）
        function setupCoordinateMapping() {
            console.log('使用坐标映射备用方案...');
            
            // 创建虚拟元素映射
            const pageKey = getCurrentPageKey();
            if (!pageElements[pageKey]) {
                pageElements[pageKey] = {};
            }
            
            // 根据已知的页面布局创建虚拟元素
            const commonElements = [
                { id: 'virtual-chart-area', name: '图表区域', rect: { left: 100, top: 100, width: 400, height: 300 } },
                { id: 'virtual-map-area', name: '地图区域', rect: { left: 500, top: 100, width: 600, height: 400 } },
                { id: 'virtual-panel-area', name: '面板区域', rect: { left: 1100, top: 100, width: 300, height: 500 } }
            ];
            
            commonElements.forEach(element => {
                pageElements[pageKey][element.id] = {
                    id: element.id,
                    name: element.name,
                    rect: element.rect,
                    virtual: true, // 标记为虚拟元素
                    selector: `virtual-${element.id}`
                };
            });
            
            console.log('✅ 虚拟元素映射已创建');
        }

        // 加载全局说明文档
        async function loadGlobalDescription() {
            const globalDescElement = document.getElementById('globalDescription');
            
            try {
                // 尝试加载本地MD文件
                const response = await fetch('prd-docs/全局说明.md');
                if (response.ok) {
                    const mdContent = await response.text();
                    // 简单的Markdown转HTML处理
                    const htmlContent = convertMarkdownToHTML(mdContent);
                    globalDescElement.innerHTML = htmlContent;
                } else {
                    throw new Error('文件未找到');
                }
            } catch (error) {
                console.log('未找到全局说明.md文件，使用默认内容');
                // 如果文件不存在，显示默认内容和提示
                globalDescElement.innerHTML = `
                    <div style="background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; padding: 12px; margin-bottom: 15px; border-radius: 0 4px 4px 0;">
                        <h4 style="color: #ffc107; margin-bottom: 8px;">📝 配置提示</h4>
                        <p style="color: #ffc107; font-size: 12px; margin: 0;">
                            请在 <code>prd-docs/</code> 目录下创建 <code>全局说明.md</code> 文件来自定义全局说明内容。
                        </p>
                    </div>
                    
                    <h4>系统概述</h4>
                    <p>临夏县农情遥感系统是基于卫星遥感技术的智能化农业监测平台，提供作物分布、灾害监测、气象分析、产量预估和长势分析等核心功能。</p>
                    
                    <h4>技术架构</h4>
                    <ul>
                        <li><strong>前端技术</strong>: HTML5, CSS3, JavaScript ES6</li>
                        <li><strong>地图引擎</strong>: Cesium.js 1.110</li>
                        <li><strong>图表库</strong>: ECharts 5.4.3</li>
                        <li><strong>设计风格</strong>: 科技感毛玻璃效果</li>
                    </ul>

                    <h4>核心特性</h4>
                    <ul>
                        <li>🗺️ 三维地图可视化</li>
                        <li>📊 实时数据图表展示</li>
                        <li>🎯 交互式操作体验</li>
                        <li>📱 响应式自适应布局</li>
                        <li>🔄 数据实时更新机制</li>
                    </ul>

                    <h4>目标用户</h4>
                    <p>农业管理部门、农技专家、农业合作社、种植大户等农业从业人员。</p>
                `;
            }
        }

        // 增强的Markdown转HTML转换器
        function convertMarkdownToHTML(markdown) {
            if (!markdown || typeof markdown !== 'string') {
                return '';
            }
            
            return markdown
                // 标题转换
                .replace(/^### (.*$)/gim, '<h4>$1</h4>')
                .replace(/^## (.*$)/gim, '<h3>$1</h3>')
                .replace(/^# (.*$)/gim, '<h2>$1</h2>')
                // 粗体转换
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // 代码转换
                .replace(/`(.*?)`/g, '<code>$1</code>')
                // 带编号的列表转换
                .replace(/^\d+\.\s+(.*$)/gim, '<li>$1</li>')
                // 普通列表转换 (支持 - 和 * 两种格式)
                .replace(/^[\-\*]\s+(.*$)/gim, '<li>$1</li>')
                // 嵌套列表转换 (支持2级缩进)
                .replace(/^  [\-\*]\s+(.*$)/gim, '<li class="nested">$1</li>')
                // 包装连续的li为ul
                .replace(/((?:<li(?:\s+class="[^"]*")?>[^<]*<\/li>\s*)+)/g, '<ul>$1</ul>')
                // 段落转换 (先处理换行)
                .replace(/\n\n+/g, '</p><p>')
                .replace(/^(?!<[uh]|<li)(.+)$/gim, '<p>$1</p>')
                // 清理多余的p标签
                .replace(/<p>(<h[1-6]>.*?<\/h[1-6]>)<\/p>/g, '$1')
                .replace(/<p>(<ul>.*?<\/ul>)<\/p>/gs, '$1')
                .replace(/<p>(<ol>.*?<\/ol>)<\/p>/gs, '$1')
                // 清理空段落
                .replace(/<p><\/p>/g, '')
                // 清理开头和结尾的空p标签
                .replace(/^<p><\/p>|<p><\/p>$/g, '');
        }

        // 计算iframe缩放比例
        function calculateIframeScale() {
            const embeddedPage = document.querySelector('.embedded-page');
            const iframe = document.getElementById('embeddedFrame');
            
            if (embeddedPage && iframe) {
                const containerWidth = embeddedPage.clientWidth;
                const containerHeight = embeddedPage.clientHeight;
                
                // 最小化边距，最大化显示区域
                const availableWidth = containerWidth - 5; // 最小边距
                const availableHeight = containerHeight - 5; // 移除顶部选择器后，最小空间
                
                // 计算缩放比例，保持1920x1080的宽高比
                const scaleX = availableWidth / 1920;
                const scaleY = availableHeight / 1080;
                const scale = Math.min(scaleX, scaleY, 1.5); // 允许放大到150%
                
                // 应用缩放
                iframe.style.transform = `scale(${scale})`;
                
                // 计算居中位置
                const scaledWidth = 1920 * scale;
                const scaledHeight = 1080 * scale;
                
                const offsetX = (containerWidth - scaledWidth) / 2;
                const offsetY = Math.max(5, (containerHeight - scaledHeight) / 2);
                
                iframe.style.left = `${Math.max(0, offsetX)}px`;
                iframe.style.top = `${offsetY}px`;
            }
        }

        // 切换页面
        async function switchPage() {
            const selectedPage = pages[currentPageIndex];
            
            const iframe = document.getElementById('embeddedFrame');
            iframe.src = '/prototype/' + selectedPage;
            
            // 重置当前功能为默认值
            currentFunction = 'crop-distribution';
            
            // 重新加载批注数据确保数据最新
            await loadAnnotations();
            
            updatePageContent();

        }



        // 更新页面内容
        async function updatePageContent() {
            const currentPage = pages[currentPageIndex];
            const config = pageConfigs[currentPage];
            
            // 更新页面说明 - 从MD文件加载
            await loadPageDescription(config.mdFile);
            
            // 更新批注内容
            const annotationContent = document.getElementById('annotationContent');
            annotationContent.innerHTML = config.annotations.map(annotation => `
                <div class="annotation-item">
                    <div class="annotation-title">${annotation.title}</div>
                    <div class="annotation-content">${convertMarkdownToHTML(annotation.content)}</div>
                </div>
            `).join('');
            
            // 更新页面元素清单
            updateElementList();
        }

        // 根据功能更新页面内容
        async function updatePageContentByFunction(functionName) {
            const config = functionConfigs[functionName];
            if (!config) return;
            
            // 重新加载批注数据确保数据最新
            await loadAnnotations();
            
            // 更新页面说明 - 从MD文件加载
            await loadPageDescription(config.mdFile);
            
            // 更新批注内容
            const annotationContent = document.getElementById('annotationContent');
            annotationContent.innerHTML = config.annotations.map(annotation => `
                <div class="annotation-item">
                    <div class="annotation-title">${annotation.title}</div>
                    <div class="annotation-content">${convertMarkdownToHTML(annotation.content)}</div>
                </div>
            `).join('');
            
            // 更新页面元素清单
            updateElementList();
        }



        // 加载页面说明文档
        async function loadPageDescription(mdFile) {
            const pageDescElement = document.getElementById('pageDescription');
            
            try {
                // 尝试加载页面对应的MD文件
                const response = await fetch(`prd-docs/${mdFile}`);
                if (response.ok) {
                    const mdContent = await response.text();
                    // 简单的Markdown转HTML处理
                    const htmlContent = convertMarkdownToHTML(mdContent);
                    pageDescElement.innerHTML = htmlContent;
                } else {
                    throw new Error('文件未找到');
                }
            } catch (error) {
                console.log(`未找到页面说明文件: ${mdFile}，使用默认内容`);
                // 如果文件不存在，显示默认内容和提示
                pageDescElement.innerHTML = `
                    <div style="background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; padding: 12px; margin-bottom: 15px; border-radius: 0 4px 4px 0;">
                        <h4 style="color: #ffc107; margin-bottom: 8px;">📝 配置提示</h4>
                        <p style="color: #ffc107; font-size: 12px; margin: 0;">
                            请在 <code>prd-docs/</code> 目录下创建 <code>${mdFile}</code> 文件来自定义页面说明内容。
                        </p>
                    </div>
                    
                    <h4>页面功能</h4>
                    <p>该页面的详细功能说明请参考外部文档。</p>
                    
                    <h4>使用说明</h4>
                    <p>请创建对应的Markdown文档来详细描述该页面的功能特性和使用方法。</p>
                `;
            }
        }



        // 更新最后更新时间
        function updateLastUpdateTime() {
            const lastUpdate = document.getElementById('lastUpdate');
            if (lastUpdate) {
                const now = new Date();
                const timeString = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                lastUpdate.textContent = timeString;
            }
        }

        // 全屏切换功能
        function toggleFullscreen() {
            const body = document.body;
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const fullscreenIcon = document.getElementById('fullscreenIcon');
            
            isFullscreen = !isFullscreen;
            
            if (isFullscreen) {
                // 进入全屏模式
                body.classList.add('fullscreen-mode');
                fullscreenIcon.textContent = '⛶';
                fullscreenBtn.title = '退出全屏';
                
                // 请求浏览器全屏
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // 退出全屏模式
                body.classList.remove('fullscreen-mode');
                fullscreenIcon.textContent = '⛶';
                fullscreenBtn.title = '全屏显示';
                
                // 退出浏览器全屏
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            
            // 重新计算iframe缩放
            setTimeout(calculateIframeScale, 300);
        }

        // 监听浏览器全屏状态变化
        function handleFullscreenChange() {
            const isInFullscreen = !!(document.fullscreenElement || 
                                    document.webkitFullscreenElement || 
                                    document.msFullscreenElement);
            
            if (!isInFullscreen && isFullscreen) {
                // 浏览器退出全屏，同步更新状态
                isFullscreen = false;
                document.body.classList.remove('fullscreen-mode');
                document.getElementById('fullscreenIcon').textContent = '⛶';
                document.getElementById('fullscreenBtn').title = '全屏显示';
                setTimeout(calculateIframeScale, 300);
            }
        }

        // 监听全屏状态变化事件
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);

        // 键盘快捷键支持
        document.addEventListener('keydown', function(event) {
            // F11 或 Ctrl+Shift+F 切换全屏
            if (event.key === 'F11' || (event.ctrlKey && event.shiftKey && event.key === 'F')) {
                event.preventDefault();
                toggleFullscreen();
            }
            // ESC 退出全屏
            if (event.key === 'Escape' && isFullscreen) {
                toggleFullscreen();
            }
        });

        // 批注模式切换
        function toggleAnnotationMode() {
            // 权限检查
            if (!checkPermission('annotation')) {
                showPermissionDenied('annotation');
                return;
            }
            
            const body = document.body;
            const annotationBtn = document.getElementById('annotationBtn');
            const annotationIcon = document.getElementById('annotationIcon');
            
            isAnnotationMode = !isAnnotationMode;
            
            if (isAnnotationMode) {
                body.classList.add('annotation-mode');
                annotationBtn.classList.add('active');
                annotationIcon.textContent = '📝';
                annotationBtn.title = '退出批注模式';
                setupAnnotationOverlay();
            } else {
                body.classList.remove('annotation-mode');
                annotationBtn.classList.remove('active');
                annotationIcon.textContent = '📝';
                annotationBtn.title = '批注模式';
                clearHighlights();
                removeAnnotationOverlay();
            }
        }

        // 设置批注覆盖层
        function setupAnnotationOverlay() {
            const embeddedPage = document.querySelector('.embedded-page');
            
            // 移除已有的覆盖层
            removeAnnotationOverlay();
            
            // 创建新的覆盖层
            const overlay = document.createElement('div');
            overlay.className = 'annotation-overlay';
            overlay.id = 'annotation-overlay';
            
            // 添加点击事件监听
            overlay.addEventListener('click', handleAnnotationClick);
            
            embeddedPage.appendChild(overlay);
        }

        // 移除批注覆盖层
        function removeAnnotationOverlay() {
            const overlay = document.getElementById('annotation-overlay');
            if (overlay) {
                overlay.removeEventListener('click', handleAnnotationClick);
                overlay.remove();
            }
        }

        // 处理批注点击事件
        function handleAnnotationClick(event) {
            if (!isAnnotationMode) return;
            
            event.preventDefault();
            event.stopPropagation();
            
            const iframe = document.getElementById('embeddedFrame');
            const iframeRect = iframe.getBoundingClientRect();
            
            // 考虑iframe的缩放比例
            const scale = parseFloat(iframe.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
            
            // 计算在iframe内的实际位置（考虑缩放）
            const x = (event.clientX - iframeRect.left) / scale;
            const y = (event.clientY - iframeRect.top) / scale;
            
            console.log('点击位置:', { x, y, scale, clientX: event.clientX, clientY: event.clientY });
            
            // 获取iframe文档中的元素
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                const targetElement = iframeDoc.elementFromPoint(x, y);
                
                console.log('原始目标元素:', targetElement);
                
                if (targetElement) {
                    // 找到最合适的父元素
                    const suitableElement = findSuitableElement(targetElement);
                    console.log('选中的合适元素:', suitableElement);
                    createAnnotationForElement(suitableElement, x, y, iframeDoc);
                }
            } catch (error) {
                console.log('无法访问iframe内容，可能是跨域限制:', error);
                alert('无法访问iframe内容，请确保页面允许跨域访问');
            }
        }

        // 找到合适的元素进行批注（优化为选择更精确的元素）
        function findSuitableElement(element) {
            let candidates = [];
            
            // 策略1: 检查点击的元素本身及其直接子元素
            const directCandidates = [element];
            
            // 添加直接子元素（如果点击的是容器，可能想选择其中的具体元素）
            if (element.children.length > 0 && element.children.length <= 5) {
                Array.from(element.children).forEach(child => {
                    directCandidates.push(child);
                });
            }
            
            // 策略2: 向上查找父元素（但限制深度，避免选择过大的容器）
            let current = element;
            let maxDepth = 4; // 减少查找深度，避免选择过大元素
            
            while (current && current !== document.body && maxDepth > 0) {
                directCandidates.push(current);
                current = current.parentElement;
                maxDepth--;
            }
            
            // 为所有候选元素评分
            directCandidates.forEach(candidate => {
                const score = calculateElementScore(candidate);
                if (score > 0) {
                    candidates.push({ 
                        element: candidate, 
                        score: score,
                        isOriginal: candidate === element,
                        isChild: element.contains(candidate) && candidate !== element,
                        isParent: candidate.contains(element) && candidate !== element
                    });
                }
            });
            
            // 特殊处理：如果原始点击元素得分很高，优先选择它
            const originalScore = candidates.find(c => c.isOriginal)?.score || 0;
            if (originalScore >= 15) {
                console.log('原始元素得分很高，直接选择:', element);
                return element;
            }
            
            console.log('候选元素:', candidates.map(c => ({
                tag: c.element.tagName,
                class: c.element.className,
                id: c.element.id,
                score: c.score,
                text: c.element.textContent?.trim().substring(0, 20),
                relation: c.isOriginal ? 'original' : c.isChild ? 'child' : c.isParent ? 'parent' : 'other'
            })));
            
            // 如果没有找到候选元素，返回原始元素
            if (candidates.length === 0) {
                return element;
            }
            
            // 按分数排序
            candidates.sort((a, b) => {
                // 在分数相近的情况下，优先选择子元素或原始元素
                if (Math.abs(a.score - b.score) <= 3) {
                    if (a.isOriginal) return -1;
                    if (b.isOriginal) return 1;
                    if (a.isChild) return -1;
                    if (b.isChild) return 1;
                }
                return b.score - a.score;
            });
            
            const selected = candidates[0].element;
            console.log('选中元素:', {
                tag: selected.tagName,
                class: selected.className,
                id: selected.id,
                score: candidates[0].score,
                text: selected.textContent?.trim().substring(0, 30)
            });
            
            return selected;
        }

        // 计算元素的重要性分数（优化为选择更精确的小元素）
        function calculateElementScore(element) {
            let score = 0;
            
            // 高优先级精确元素（优先选择具体的小组件）
            const highPriorityClasses = [
                'panel-title', 'panel-header', 'chart-title', 'widget-title',
                'button', 'btn', 'icon', 'label', 'badge', 'tag',
                'input', 'select', 'textarea', 'checkbox', 'radio',
                'link', 'nav-item', 'menu-item', 'dropdown-item',
                'card-title', 'card-header', 'stat-item', 'metric'
            ];
            
            // 中优先级具体元素
            const mediumPriorityClasses = [
                'chart', 'graph', 'table', 'list-item', 'item',
                'block', 'box', 'tile', 'thumbnail', 'avatar',
                'switch-btn', 'main-switch-btn', 'overlay-switch-btn'
            ];
            
            // 低优先级大容器（尽量避免选择）
            const lowPriorityClasses = [
                'panel', 'container', 'wrapper', 'content', 'body',
                'main', 'section', 'row', 'col', 'grid', 'layout'
            ];
            
            // 检查类名
            if (element.className) {
                const classes = element.className.split(' ');
                for (const cls of classes) {
                    if (highPriorityClasses.some(priority => cls.includes(priority))) {
                        score += 15; // 提高小元素优先级
                    } else if (mediumPriorityClasses.some(priority => cls.includes(priority))) {
                        score += 8;
                    } else if (lowPriorityClasses.some(priority => cls.includes(priority))) {
                        score -= 3; // 降低大容器优先级
                    }
                }
            }
            
            // ID 权重（但如果是大容器ID则降低权重）
            if (element.id) {
                const largeContainerIds = ['main', 'content', 'container', 'wrapper', 'app'];
                if (largeContainerIds.some(id => element.id.includes(id))) {
                    score += 2; // 大容器ID权重较低
                } else {
                    score += 10; // 具体元素ID权重较高
                }
            }
            
            // data-* 属性权重
            if (element.hasAttribute('data-function') || 
                element.hasAttribute('data-type') || 
                element.hasAttribute('data-widget') ||
                element.hasAttribute('data-chart') ||
                element.hasAttribute('onclick')) {
                score += 12;
            }
            
            // 交互元素权重（这些通常是用户真正想要批注的元素）
            const interactiveTags = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A', 'LABEL'];
            if (interactiveTags.includes(element.tagName)) {
                score += 15;
            }
            
            // 内容元素权重
            const contentTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'SPAN', 'STRONG', 'EM'];
            if (contentTags.includes(element.tagName)) {
                score += 10;
            }
            
            // 图像和媒体元素
            const mediaTags = ['IMG', 'SVG', 'CANVAS', 'VIDEO'];
            if (mediaTags.includes(element.tagName)) {
                score += 12;
            }
            
            // 尺寸权重优化（偏向选择中等大小的元素）
            const rect = element.getBoundingClientRect();
            if (rect.width < 10 || rect.height < 10) {
                score -= 10; // 太小的元素
            } else if (rect.width < 30 || rect.height < 30) {
                score += 5; // 小元素（图标、按钮等）
            } else if (rect.width <= 200 && rect.height <= 100) {
                score += 10; // 中等大小元素（最佳选择）
            } else if (rect.width <= 400 && rect.height <= 200) {
                score += 5; // 稍大的元素
            } else {
                score -= 5; // 大型容器元素
            }
            
            // 避免选择根元素和大容器
            const avoidTags = ['BODY', 'HTML', 'HEAD', 'MAIN', 'SECTION', 'ARTICLE'];
            if (avoidTags.includes(element.tagName)) {
                score -= 25;
            }
            
            // 文本内容权重（偏向有适量文本的元素）
            const textContent = element.textContent?.trim();
            if (textContent) {
                if (textContent.length <= 3) {
                    score += 8; // 短文本（如按钮、标签）
                } else if (textContent.length <= 20) {
                    score += 12; // 标题、短描述
                } else if (textContent.length <= 50) {
                    score += 8; // 中等文本
                } else {
                    score += 2; // 长文本（可能是大容器）
                }
            }
            
            // 子元素数量权重（偏向选择叶子节点或简单元素）
            const childCount = element.children.length;
            if (childCount === 0) {
                score += 8; // 叶子节点优先
            } else if (childCount <= 3) {
                score += 5; // 简单元素
            } else if (childCount <= 10) {
                score += 2; // 中等复杂元素
            } else {
                score -= 5; // 复杂容器
            }
            
            // 特殊属性加分
            if (element.hasAttribute('title') || element.hasAttribute('alt')) {
                score += 5;
            }
            
            // 可见性检查
            const style = window.getComputedStyle(element);
            if (style.display === 'none' || style.visibility === 'hidden') {
                score -= 20;
            }
            
            console.log(`元素 ${element.tagName}.${element.className} 得分:`, score, 
                       `尺寸: ${rect.width}x${rect.height}`, 
                       `子元素: ${childCount}`,
                       `文本长度: ${textContent?.length || 0}`);
            return score;
        }

        // 为元素创建批注 - 精确版
        function createAnnotationForElement(element, x, y, iframeDoc) {
            console.log('🎯 创建元素批注 - 精确版');
            const pageKey = getCurrentPageKey();
            
            // 生成多重元素标识和定位信息
            const elementSignature = generateElementSignature(element, iframeDoc);
            const elementId = elementSignature.id;
            
            // 记录完整的元素信息
            if (!pageElements[pageKey]) {
                pageElements[pageKey] = {};
            }
            
            pageElements[pageKey][elementId] = elementSignature;
            
            // 选中这个元素
            selectedElementId = elementId;
            
            // 立即验证定位准确性
            const canRelocate = testElementRelocation(elementId, iframeDoc);
            console.log('🔍 定位验证结果:', canRelocate);
            
            // 高亮元素
            highlightElement(elementId);
            
            // 更新元素清单
            updateElementList();
            
            // 显示批注创建界面
            updateAnnotationDisplay(elementId);
            
            console.log('✅ 元素批注创建完成:', {
                elementId,
                signature: elementSignature,
                canRelocate
            });
        }
        
        // 生成元素签名（包含多重定位信息）
        function generateElementSignature(element, iframeDoc) {
            console.log('📝 生成元素签名:', element);
            
            const rect = element.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(element);
            
            // 基础信息
            const basic = {
                tagName: element.tagName.toLowerCase(),
                id: element.id || null,
                className: element.className || null,
                textContent: element.textContent ? element.textContent.trim().substring(0, 50) : null
            };
            
            // 为Canvas元素生成智能名称
            if (element.tagName.toLowerCase() === 'canvas') {
                basic.smartName = generateCanvasDisplayName(element);
            }
            
            // 层级路径信息
            const hierarchy = generateElementPath(element);
            
            // 属性特征
            const attributes = {};
            if (element.attributes) {
                for (let attr of element.attributes) {
                    if (['id', 'class', 'data-', 'src', 'href', 'type', 'name', 'value'].some(prefix => 
                        attr.name === prefix || attr.name.startsWith(prefix))) {
                        attributes[attr.name] = attr.value;
                    }
                }
            }
            
            // 位置信息（多重）
            const positioning = {
                // 绝对坐标
                absoluteRect: {
                    top: rect.top,
                    left: rect.left,
                    width: rect.width,
                    height: rect.height,
                    right: rect.right,
                    bottom: rect.bottom
                },
                // 相对父元素位置
                relativePosition: getRelativePosition(element),
                // 在同级元素中的索引
                siblingIndex: getSiblingIndex(element),
                // 在同类型元素中的索引
                typeIndex: getTypeIndex(element)
            };
            
            // 样式特征（用于识别）
            const styleFeatures = {
                display: computedStyle.display,
                position: computedStyle.position,
                backgroundColor: computedStyle.backgroundColor,
                color: computedStyle.color,
                fontSize: computedStyle.fontSize,
                zIndex: computedStyle.zIndex
            };
            
            // 生成多个选择器
            const selectors = {
                primary: generatePrimarySelector(element),
                xpath: generateXPath(element),
                cssPath: generateCSSPath(element),
                unique: generateUniqueSelector(element, iframeDoc),
                backup: generateBackupSelectors(element)
            };
            
            // 内容特征
            const contentFeatures = {
                hasText: !!element.textContent?.trim(),
                hasChildren: element.children.length > 0,
                childCount: element.children.length,
                isLeaf: element.children.length === 0,
                innerHTML: element.innerHTML ? element.innerHTML.substring(0, 200) : null
            };
            
            // 生成稳定ID
            const stableId = generateStableElementId(basic, hierarchy, positioning);
            
            return {
                id: stableId,
                timestamp: Date.now(),
                basic,
                hierarchy,
                attributes,
                positioning,
                styleFeatures,
                contentFeatures,
                selectors,
                // 保存原始元素引用（仅在当前会话有效）
                _element: element,
                // 验证函数
                validate: function(testElement) {
                    return validateElementMatch(this, testElement);
                }
            };
        }
        
        // 生成元素层级路径
        function generateElementPath(element) {
            const path = [];
            let current = element;
            let depth = 0;
            const maxDepth = 10;
            
            while (current && current !== document.body && depth < maxDepth) {
                const step = {
                    tagName: current.tagName.toLowerCase(),
                    id: current.id || null,
                    className: current.className || null,
                    index: Array.from(current.parentElement?.children || []).indexOf(current)
                };
                path.unshift(step);
                current = current.parentElement;
                depth++;
            }
            
            return {
                path,
                depth,
                fullPath: path.map(step => 
                    `${step.tagName}${step.id ? '#' + step.id : ''}${step.className ? '.' + step.className.split(' ')[0] : ''}[${step.index}]`
                ).join(' > ')
            };
        }
        
        // 获取相对位置
        function getRelativePosition(element) {
            const parent = element.parentElement;
            if (!parent) return null;
            
            const parentRect = parent.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();
            
            return {
                offsetTop: elementRect.top - parentRect.top,
                offsetLeft: elementRect.left - parentRect.left,
                offsetWidth: elementRect.width,
                offsetHeight: elementRect.height,
                parentTagName: parent.tagName.toLowerCase(),
                parentClassName: parent.className || null
            };
        }
        
        // 获取同级索引
        function getSiblingIndex(element) {
            const siblings = Array.from(element.parentElement?.children || []);
            return {
                total: siblings.length,
                index: siblings.indexOf(element),
                isFirst: siblings.indexOf(element) === 0,
                isLast: siblings.indexOf(element) === siblings.length - 1
            };
        }
        
        // 获取同类型索引
        function getTypeIndex(element) {
            const sameTypeElements = Array.from(
                element.parentElement?.querySelectorAll(element.tagName) || []
            );
            return {
                total: sameTypeElements.length,
                index: sameTypeElements.indexOf(element),
                isUnique: sameTypeElements.length === 1
            };
        }

        // 生成主要选择器
        function generatePrimarySelector(element) {
            if (element.id) {
                return `#${element.id}`;
            }
            
            let selector = element.tagName.toLowerCase();
            
            if (element.className) {
                const classes = element.className.split(' ').filter(cls => cls.trim());
                if (classes.length > 0) {
                    selector += '.' + classes.slice(0, 3).join('.');
                }
            }
            
            return selector;
        }
        
        // 生成XPath
        function generateXPath(element) {
            if (element.id) {
                return `//*[@id="${element.id}"]`;
            }
            
            const parts = [];
            let current = element;
            
            while (current && current.nodeType === Node.ELEMENT_NODE) {
                let part = current.tagName.toLowerCase();
                
                if (current.id) {
                    part += `[@id="${current.id}"]`;
                    parts.unshift('//' + part);
                    break;
                } else {
                    const siblings = Array.from(current.parentNode?.children || [])
                        .filter(sibling => sibling.tagName === current.tagName);
                    
                    if (siblings.length > 1) {
                        const index = siblings.indexOf(current) + 1;
                        part += `[${index}]`;
                    }
                    
                    parts.unshift(part);
                }
                
                current = current.parentNode;
                if (parts.length > 5) break; // 限制深度
            }
            
            return '//' + parts.join('/');
        }
        
        // 生成CSS路径
        function generateCSSPath(element) {
            const parts = [];
            let current = element;
            
            while (current && current.nodeType === Node.ELEMENT_NODE && current !== document.body) {
                let selector = current.tagName.toLowerCase();
                
                if (current.id) {
                    selector += '#' + current.id;
                    parts.unshift(selector);
                    break;
                } else if (current.className) {
                    const classes = current.className.split(' ').filter(cls => cls.trim());
                    if (classes.length > 0) {
                        selector += '.' + classes[0];
                    }
                }
                
                // 添加nth-child选择器以确保唯一性
                const siblings = Array.from(current.parentNode?.children || []);
                const index = siblings.indexOf(current) + 1;
                selector += `:nth-child(${index})`;
                
                parts.unshift(selector);
                current = current.parentNode;
                
                if (parts.length > 4) break; // 限制深度
            }
            
            return parts.join(' > ');
        }
        
        // 生成唯一选择器
        function generateUniqueSelector(element, doc) {
            // 尝试多种唯一标识策略
            const strategies = [];
            
            // 策略1: ID选择器
            if (element.id) {
                strategies.push(`#${element.id}`);
            }
            
            // 策略2: data属性
            for (let attr of element.attributes || []) {
                if (attr.name.startsWith('data-') && attr.value) {
                    strategies.push(`[${attr.name}="${attr.value}"]`);
                }
            }
            
            // 策略3: 唯一类名组合
            if (element.className) {
                const classes = element.className.split(' ').filter(cls => cls.trim());
                for (let i = 1; i <= Math.min(classes.length, 3); i++) {
                    const classSelector = '.' + classes.slice(0, i).join('.');
                    if (doc.querySelectorAll(classSelector).length === 1) {
                        strategies.push(classSelector);
                        break;
                    }
                }
            }
            
            // 策略4: 文本内容选择器
            const textContent = element.textContent?.trim();
            if (textContent && textContent.length < 30) {
                const escaped = textContent.replace(/"/g, '\\"');
                strategies.push(`${element.tagName.toLowerCase()}:contains("${escaped}")`);
            }
            
            // 策略5: 属性组合
            const uniqueAttrs = ['name', 'type', 'href', 'src', 'value'];
            for (let attrName of uniqueAttrs) {
                const attrValue = element.getAttribute(attrName);
                if (attrValue) {
                    const attrSelector = `[${attrName}="${attrValue}"]`;
                    if (doc.querySelectorAll(attrSelector).length === 1) {
                        strategies.push(attrSelector);
                        break;
                    }
                }
            }
            
            return strategies;
        }
        
        // 生成备用选择器
        function generateBackupSelectors(element) {
            const backups = [];
            
            // 备用1: 标签+位置
            const siblings = Array.from(element.parentNode?.children || []);
            const index = siblings.indexOf(element);
            backups.push(`${element.tagName.toLowerCase()}:nth-child(${index + 1})`);
            
            // 备用2: 标签+类名+位置
            if (element.className) {
                const firstClass = element.className.split(' ')[0];
                backups.push(`${element.tagName.toLowerCase()}.${firstClass}:nth-child(${index + 1})`);
            }
            
            // 备用3: 相对父元素的选择器
            const parent = element.parentElement;
            if (parent && parent.id) {
                backups.push(`#${parent.id} > ${element.tagName.toLowerCase()}:nth-child(${index + 1})`);
            }
            
            return backups;
        }
        
        // ========== Canvas智能识别系统 ==========
        
        // 生成Canvas唯一签名
        function generateCanvasSignature(canvasElement) {
            const signatures = [];
            
            // 1. 基础物理特征
            const width = canvasElement.width || canvasElement.offsetWidth || 0;
            const height = canvasElement.height || canvasElement.offsetHeight || 0;
            signatures.push(`size-${width}x${height}`);
            
            // 2. 检测ECharts实例
            const echartsInfo = detectEChartsInstance(canvasElement);
            if (echartsInfo.isECharts) {
                signatures.push('echarts');
                
                // ECharts图表类型
                if (echartsInfo.chartType) {
                    signatures.push(`type-${echartsInfo.chartType}`);
                }
                
                // ECharts标题作为唯一标识
                if (echartsInfo.title) {
                    const titleSlug = echartsInfo.title
                        .replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '')
                        .substring(0, 10);
                    signatures.push(`title-${titleSlug}`);
                }
                
                // ECharts实例ID
                if (echartsInfo.instanceId) {
                    signatures.push(`inst-${echartsInfo.instanceId}`);
                }
            } else {
                // 非ECharts的canvas特征
                signatures.push('native');
                
                // 检测canvas上下文类型
                try {
                    if (canvasElement.getContext('2d')) {
                        signatures.push('2d');
                    } else if (canvasElement.getContext('webgl') || canvasElement.getContext('experimental-webgl')) {
                        signatures.push('webgl');
                    } else if (canvasElement.getContext('webgl2')) {
                        signatures.push('webgl2');
                    }
                } catch (e) {
                    signatures.push('protected');
                }
            }
            
            // 3. 容器上下文特征
            const containerInfo = analyzeCanvasContainer(canvasElement);
            if (containerInfo.containerId) {
                signatures.push(`container-${containerInfo.containerId}`);
            }
            if (containerInfo.purpose) {
                const purposeSlug = containerInfo.purpose.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '').substring(0, 8);
                signatures.push(`purpose-${purposeSlug}`);
            }
            
            // 4. 位置特征（用于区分相同类型的多个canvas）
            const positionInfo = getCanvasPositionContext(canvasElement);
            signatures.push(`pos-${positionInfo.gridPosition}`);
            if (positionInfo.isUnique) {
                signatures.push('unique');
            }
            
            // 5. 数据属性和类名特征
            const dataFeatures = extractCanvasDataFeatures(canvasElement);
            signatures.push(...dataFeatures);
            
            return signatures.join('-');
        }
        
        // 检测ECharts实例（增强版）
        function detectEChartsInstance(canvasElement) {
            const result = {
                isECharts: false,
                chartType: null,
                title: null,
                instanceId: null,
                option: null,
                containerElement: null
            };
            
            try {
                // 方法1: 检查ZRender标识
                if (canvasElement.getAttribute('data-zr-dom-id')) {
                    result.isECharts = true;
                    result.instanceId = canvasElement.getAttribute('data-zr-dom-id');
                }
                
                // 方法2: 向上查找ECharts容器
                let parent = canvasElement.parentElement;
                let echartsContainer = null;
                let level = 0;
                
                while (parent && level < 5) {
                    // 检查ECharts实例属性
                    if (parent._echarts_instance_ || 
                        parent.getAttribute('_echarts_instance_') ||
                        parent.classList.contains('echarts-instance')) {
                        echartsContainer = parent;
                        result.containerElement = parent;
                        result.isECharts = true;
                        break;
                    }
                    
                    // 检查容器特征
                    const containerId = parent.id || '';
                    const containerClass = parent.className || '';
                    
                    if (containerId.includes('chart') || containerId.includes('echarts') ||
                        containerClass.includes('chart') || containerClass.includes('echarts')) {
                        echartsContainer = parent;
                        result.containerElement = parent;
                        result.isECharts = true;
                        break;
                    }
                    
                    parent = parent.parentElement;
                    level++;
                }
                
                // 方法3: 通过全局echarts对象获取实例
                if (echartsContainer && window.echarts) {
                    try {
                        const instance = echarts.getInstanceByDom(echartsContainer);
                        if (instance) {
                            result.isECharts = true;
                            result.option = instance.getOption();
                            
                            // 解析图表信息
                            if (result.option) {
                                // 获取标题
                                if (result.option.title) {
                                    const titleConfig = Array.isArray(result.option.title) ? 
                                        result.option.title[0] : result.option.title;
                                    if (titleConfig && titleConfig.text) {
                                        result.title = titleConfig.text;
                                    }
                                }
                                
                                // 获取图表类型
                                if (result.option.series && result.option.series[0]) {
                                    result.chartType = result.option.series[0].type;
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('获取ECharts实例失败:', error);
                    }
                }
                
                // 方法4: 检查容器的数据属性和标题
                if (echartsContainer) {
                    // 数据属性中的标题
                    const dataTitle = echartsContainer.getAttribute('data-chart-title') ||
                                     echartsContainer.getAttribute('data-title') ||
                                     echartsContainer.getAttribute('title');
                    if (dataTitle && !result.title) {
                        result.title = dataTitle;
                    }
                    
                    // 数据属性中的图表类型
                    const dataType = echartsContainer.getAttribute('data-chart-type') ||
                                    echartsContainer.getAttribute('data-type');
                    if (dataType && !result.chartType) {
                        result.chartType = dataType;
                    }
                    
                    // 查找相邻的标题元素
                    if (!result.title) {
                        const titleElement = echartsContainer.querySelector('.chart-title, .title, h1, h2, h3, h4, h5, h6') ||
                                           echartsContainer.previousElementSibling?.querySelector('h1, h2, h3, h4, h5, h6') ||
                                           echartsContainer.nextElementSibling?.querySelector('h1, h2, h3, h4, h5, h6');
                        
                        if (titleElement && titleElement.textContent) {
                            result.title = titleElement.textContent.trim();
                        }
                    }
                }
                
            } catch (error) {
                console.warn('检测ECharts实例时出错:', error);
            }
            
            return result;
        }
        
        // 分析Canvas容器上下文
        function analyzeCanvasContainer(canvasElement) {
            const info = {
                containerId: null,
                purpose: null,
                level: 0
            };
            
            let parent = canvasElement.parentElement;
            let level = 0;
            
            while (parent && level < 5) {
                const id = parent.id || '';
                const className = parent.className || '';
                const tagName = parent.tagName.toLowerCase();
                
                // 记录容器ID
                if (id && !info.containerId) {
                    info.containerId = id.replace(/[^\w\-]/g, '').substring(0, 15);
                }
                
                // 检查语义化用途
                const purposes = [
                    'chart', 'graph', 'plot', 'diagram', 'visualization', 
                    'dashboard', 'monitor', 'analytics', 'report', 'overview',
                    'metric', 'kpi', 'stats', 'data'
                ];
                
                for (const purpose of purposes) {
                    if (id.includes(purpose) || className.includes(purpose)) {
                        info.purpose = purpose;
                        info.level = level;
                        break;
                    }
                }
                
                // 特殊容器检测
                if (className.includes('cesium') || id.includes('cesium')) {
                    info.purpose = 'cesium3d';
                    break;
                }
                
                if (className.includes('leaflet') || id.includes('leaflet')) {
                    info.purpose = 'leafletmap';
                    break;
                }
                
                if (info.purpose) break;
                
                parent = parent.parentElement;
                level++;
            }
            
            return info;
        }
        
        // 获取Canvas位置上下文
        function getCanvasPositionContext(canvasElement) {
            const rect = canvasElement.getBoundingClientRect();
            const allCanvases = document.querySelectorAll('canvas');
            const canvasIndex = Array.from(allCanvases).indexOf(canvasElement);
            
            // 计算网格位置
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let gridX = 'c'; // center
            if (centerX < viewportWidth * 0.33) gridX = 'l'; // left
            else if (centerX > viewportWidth * 0.67) gridX = 'r'; // right
            
            let gridY = 'm'; // middle  
            if (centerY < viewportHeight * 0.33) gridY = 't'; // top
            else if (centerY > viewportHeight * 0.67) gridY = 'b'; // bottom
            
            const gridPosition = gridX + gridY;
            
            // 检查是否在相同位置有其他canvas
            const samePositionCanvases = Array.from(allCanvases).filter(canvas => {
                if (canvas === canvasElement) return false;
                const otherRect = canvas.getBoundingClientRect();
                const otherCenterX = otherRect.left + otherRect.width / 2;
                const otherCenterY = otherRect.top + otherRect.height / 2;
                
                let otherGridX = 'c';
                if (otherCenterX < viewportWidth * 0.33) otherGridX = 'l';
                else if (otherCenterX > viewportWidth * 0.67) otherGridX = 'r';
                
                let otherGridY = 'm';
                if (otherCenterY < viewportHeight * 0.33) otherGridY = 't';
                else if (otherCenterY > viewportHeight * 0.67) otherGridY = 'b';
                
                return (otherGridX + otherGridY) === gridPosition;
            });
            
            return {
                gridPosition: samePositionCanvases.length > 0 ? 
                    `${gridPosition}${canvasIndex}` : gridPosition,
                isUnique: samePositionCanvases.length === 0,
                totalCanvases: allCanvases.length,
                index: canvasIndex
            };
        }
        
        // 提取Canvas数据特征
        function extractCanvasDataFeatures(canvasElement) {
            const features = [];
            
            // 检查自身的数据属性
            const dataset = canvasElement.dataset || {};
            for (const [key, value] of Object.entries(dataset)) {
                if (key.length <= 15 && value.length <= 15) {
                    const cleanKey = key.replace(/[^\w]/g, '').toLowerCase();
                    const cleanValue = String(value).replace(/[^\w\u4e00-\u9fa5]/g, '').substring(0, 8);
                    if (cleanKey && cleanValue) {
                        features.push(`data-${cleanKey}-${cleanValue}`);
                    }
                }
            }
            
            // 检查类名特征
            const className = canvasElement.className || '';
            if (className) {
                const classFeature = className
                    .split(' ')
                    .filter(cls => cls && cls.length > 2 && cls.length <= 15)
                    .map(cls => cls.replace(/[^\w\-]/g, ''))
                    .slice(0, 2)
                    .join('-');
                if (classFeature) {
                    features.push(`class-${classFeature}`);
                }
            }
            
            // 检查ID特征
            const id = canvasElement.id || '';
            if (id && id.length <= 20) {
                const idFeature = id.replace(/[^\w\-]/g, '').substring(0, 10);
                features.push(`id-${idFeature}`);
            }
            
            return features.slice(0, 3); // 最多3个特征避免签名过长
        }
        
        // 生成Canvas友好显示名称
        function generateCanvasDisplayName(canvasElement) {
            // 首先尝试检测ECharts
            const echartsInfo = detectEChartsInstance(canvasElement);
            if (echartsInfo.isECharts) {
                if (echartsInfo.title) {
                    return echartsInfo.title;
                }
                
                const chartTypeMap = {
                    'line': '折线图',
                    'bar': '柱状图',
                    'pie': '饼图',
                    'scatter': '散点图',
                    'map': '地图',
                    'radar': '雷达图',
                    'gauge': '仪表盘',
                    'funnel': '漏斗图',
                    'sankey': '桑基图',
                    'heatmap': '热力图',
                    'tree': '树图',
                    'treemap': '矩形树图',
                    'sunburst': '旭日图',
                    'boxplot': '箱线图',
                    'candlestick': 'K线图',
                    'parallel': '平行坐标图',
                    'graph': '关系图',
                    'liquidfill': '水球图',
                    'wordcloud': '词云图'
                };
                
                if (echartsInfo.chartType) {
                    const chartTypeName = chartTypeMap[echartsInfo.chartType] || `${echartsInfo.chartType}图表`;
                    return `ECharts ${chartTypeName}`;
                }
                
                return 'ECharts图表';
            }
            
            // 分析容器上下文
            const containerInfo = analyzeCanvasContainer(canvasElement);
            if (containerInfo.purpose) {
                const purposeMap = {
                    'cesium3d': 'Cesium 3D地图',
                    'leafletmap': 'Leaflet地图',
                    'chart': '图表Canvas',
                    'graph': '图形Canvas',
                    'plot': '绘图Canvas',
                    'diagram': '图解Canvas',
                    'visualization': '可视化Canvas',
                    'dashboard': '仪表板Canvas',
                    'monitor': '监控Canvas',
                    'analytics': '分析Canvas',
                    'report': '报表Canvas',
                    'overview': '概览Canvas'
                };
                
                if (purposeMap[containerInfo.purpose]) {
                    return purposeMap[containerInfo.purpose];
                }
            }
            
            // 检查canvas特定属性
            const dataTitle = canvasElement.getAttribute('data-title') ||
                             canvasElement.getAttribute('data-name') ||
                             canvasElement.getAttribute('title') ||
                             canvasElement.getAttribute('alt');
            if (dataTitle && dataTitle.trim()) {
                return dataTitle.trim();
            }
            
            // 根据尺寸和位置生成描述性名称
            const width = canvasElement.width || canvasElement.offsetWidth || 0;
            const height = canvasElement.height || canvasElement.offsetHeight || 0;
            
            let sizeDesc = '';
            const area = width * height;
            if (area > 800000) {
                sizeDesc = '大型';
            } else if (area > 200000) {
                sizeDesc = '中型';
            } else if (area > 50000) {
                sizeDesc = '小型';
            } else {
                sizeDesc = '微型';
            }
            
            // 检查上下文类型
            let contextDesc = 'Canvas';
            try {
                if (canvasElement.getContext('2d')) {
                    contextDesc = '2D Canvas';
                } else if (canvasElement.getContext('webgl') || canvasElement.getContext('experimental-webgl')) {
                    contextDesc = 'WebGL Canvas';
                } else if (canvasElement.getContext('webgl2')) {
                    contextDesc = 'WebGL2 Canvas';
                }
            } catch (e) {
                contextDesc = '受保护 Canvas';
            }
            
            // 位置信息
            const allCanvases = document.querySelectorAll('canvas');
            if (allCanvases.length > 1) {
                const index = Array.from(allCanvases).indexOf(canvasElement) + 1;
                const rect = canvasElement.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let position = '';
                if (centerX < viewportWidth * 0.33) position += '左';
                else if (centerX > viewportWidth * 0.67) position += '右';
                else position += '中';
                
                if (centerY < viewportHeight * 0.33) position += '上';
                else if (centerY > viewportHeight * 0.67) position += '下';
                else position += '央';
                
                return `${position}${sizeDesc}${contextDesc} #${index}`;
            }
            
            return `${sizeDesc}${contextDesc}`;
        }
        
        // 获取元素的显示名称
        function getElementDisplayName(element) {
            if (!element) return '未知元素';
            
            // 如果有智能名称，优先使用
            if (element.basic && element.basic.smartName) {
                return element.basic.smartName;
            }
            
            // 如果是Canvas元素，生成智能名称
            if (element._element && element._element.tagName.toLowerCase() === 'canvas') {
                return generateCanvasDisplayName(element._element);
            }
            
            // 使用原有的名称逻辑
            if (element.name) {
                return element.name;
            }
            
            // 回退到基础名称生成
            if (element.basic) {
                const tagName = element.basic.tagName || 'unknown';
                
                // 检查是否有文本内容
                if (element.basic.textContent && element.basic.textContent.trim()) {
                    const text = element.basic.textContent.trim();
                    if (text.length <= 20) {
                        return `${tagName}: ${text}`;
                    } else {
                        return `${tagName}: ${text.substring(0, 15)}...`;
                    }
                }
                
                // 检查是否有ID
                if (element.basic.id) {
                    return `${tagName}#${element.basic.id}`;
                }
                
                // 检查是否有class
                if (element.basic.className) {
                    const firstClass = element.basic.className.split(' ')[0];
                    return `${tagName}.${firstClass}`;
                }
                
                return tagName.toUpperCase();
            }
            
            return '未知元素';
        }
        
        // 生成稳定元素ID
        function generateStableElementId(basic, hierarchy, positioning) {
            // 使用多个特征生成稳定ID
            const features = [
                basic.tagName,
                basic.id || 'noid',
                basic.className?.split(' ')[0] || 'noclass',
                hierarchy.depth,
                positioning.siblingIndex.index,
                positioning.typeIndex.index
            ];
            
            // 添加内容特征
            if (basic.textContent && basic.textContent.length < 20) {
                features.push(basic.textContent.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, ''));
            }
            
            const idString = features.join('-');
            return `precise-${idString}`.replace(/[^a-zA-Z0-9\u4e00-\u9fa5-]/g, '-').replace(/-+/g, '-');
        }
        
        // 验证元素匹配
        function validateElementMatch(signature, testElement) {
            if (!testElement) return { score: 0, reason: '元素不存在' };
            
            let score = 0;
            const reasons = [];
            
            // 基础信息匹配 (40分)
            if (signature.basic.tagName === testElement.tagName.toLowerCase()) {
                score += 15;
                reasons.push('标签匹配');
            }
            
            if (signature.basic.id && signature.basic.id === testElement.id) {
                score += 25;
                reasons.push('ID完全匹配');
            }
            
            if (signature.basic.className && testElement.className.includes(signature.basic.className.split(' ')[0])) {
                score += 10;
                reasons.push('类名匹配');
            }
            
            // 位置信息匹配 (30分)
            const siblings = Array.from(testElement.parentElement?.children || []);
            const currentIndex = siblings.indexOf(testElement);
            if (currentIndex === signature.positioning.siblingIndex.index) {
                score += 15;
                reasons.push('位置索引匹配');
            }
            
            const rect = testElement.getBoundingClientRect();
            const sizeDiff = Math.abs(rect.width - signature.positioning.absoluteRect.width) + 
                           Math.abs(rect.height - signature.positioning.absoluteRect.height);
            if (sizeDiff < 20) {
                score += 15;
                reasons.push('尺寸相似');
            }
            
            // 内容匹配 (20分)
            if (signature.contentFeatures.hasText && testElement.textContent?.trim()) {
                const textSimilarity = calculateTextSimilarity(
                    signature.basic.textContent, 
                    testElement.textContent.trim().substring(0, 50)
                );
                score += Math.round(textSimilarity * 20);
                if (textSimilarity > 0.8) reasons.push('文本内容匹配');
            }
            
            // 属性匹配 (10分)
            let attrMatches = 0;
            for (let [attrName, attrValue] of Object.entries(signature.attributes)) {
                if (testElement.getAttribute(attrName) === attrValue) {
                    attrMatches++;
                }
            }
            if (attrMatches > 0) {
                score += Math.min(attrMatches * 5, 10);
                reasons.push(`${attrMatches}个属性匹配`);
            }
            
            return {
                score,
                reasons,
                isMatch: score >= 70, // 70分以上认为匹配
                confidence: score / 100
            };
        }
        
        // 计算文本相似度
        function calculateTextSimilarity(text1, text2) {
            if (!text1 || !text2) return 0;
            
            text1 = text1.toLowerCase().trim();
            text2 = text2.toLowerCase().trim();
            
            if (text1 === text2) return 1;
            
            const longer = text1.length > text2.length ? text1 : text2;
            const shorter = text1.length > text2.length ? text2 : text1;
            
            if (longer.length === 0) return 1;
            
            const editDistance = calculateEditDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        // 计算编辑距离
        function calculateEditDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        // 测试元素重定位
        function testElementRelocation(elementId, iframeDoc) {
            const pageKey = getCurrentPageKey();
            const signature = pageElements[pageKey]?.[elementId];
            
            if (!signature) return false;
            
            try {
                const foundElement = relocateElementBySignature(signature, iframeDoc);
                return !!foundElement;
            } catch (error) {
                console.log('重定位测试失败:', error);
                return false;
            }
        }
        
        // 根据签名重定位元素
        function relocateElementBySignature(signature, iframeDoc) {
            console.log('🔍 根据签名重定位元素:', signature.id);
            
            // 策略1: 使用primary选择器
            if (signature.selectors.primary) {
                try {
                    const element = iframeDoc.querySelector(signature.selectors.primary);
                    if (element) {
                        const validation = signature.validate(element);
                        console.log('Primary选择器验证:', validation);
                        if (validation.isMatch) {
                            return element;
                        }

                    }
                } catch (e) {
                    console.log('Primary选择器失败:', e);
                }

            }
            
            // 策略2: 使用unique选择器
            for (let uniqueSelector of signature.selectors.unique || []) {
                try {
                    const element = iframeDoc.querySelector(uniqueSelector);
                    if (element) {
                        const validation = signature.validate(element);
                        console.log('Unique选择器验证:', validation);
                        if (validation.isMatch) {
                            return element;
                        }
                    }
                } catch (e) {
                    console.log('Unique选择器失败:', uniqueSelector, e);
                }
            }
            
            // 策略3: 使用CSS路径
            if (signature.selectors.cssPath) {
                try {
                    const element = iframeDoc.querySelector(signature.selectors.cssPath);
                    if (element) {
                        const validation = signature.validate(element);
                        console.log('CSS路径验证:', validation);
                        if (validation.isMatch) {
                            return element;
                        }
                    }
                } catch (e) {
                    console.log('CSS路径失败:', e);
                }
            }
            
            // 策略4: 使用层级路径重建
            const pathElement = findElementByPath(signature.hierarchy, iframeDoc);
            if (pathElement) {
                const validation = signature.validate(pathElement);
                console.log('路径重建验证:', validation);
                if (validation.isMatch) {
                    return pathElement;
                }
            }
            
            // 策略5: 相似度匹配
            const candidates = findSimilarElements(signature, iframeDoc);
            if (candidates.length > 0) {
                console.log('找到相似元素候选:', candidates.length);
                return candidates[0].element;
            }
            
            console.log('❌ 所有重定位策略都失败了');
            return null;
        }
        
        // 根据路径查找元素
        function findElementByPath(hierarchy, iframeDoc) {
            try {
                let current = iframeDoc.body;
                
                for (let step of hierarchy.path) {
                    const children = Array.from(current.children);
                    const candidate = children[step.index];
                    
                    if (!candidate || candidate.tagName.toLowerCase() !== step.tagName) {
                        return null;
                    }
                    
                    current = candidate;
                }
                
                return current;
            } catch (error) {
                console.log('路径查找失败:', error);
                return null;
            }
        }
        
        // 查找相似元素
        function findSimilarElements(signature, iframeDoc) {
            const candidates = [];
            const allElements = iframeDoc.querySelectorAll(signature.basic.tagName);
            
            for (let element of allElements) {
                const validation = signature.validate(element);
                if (validation.score > 50) { // 50分以上的相似元素
                    candidates.push({
                        element,
                        score: validation.score,
                        reasons: validation.reasons
                    });
                }
            }
            
            // 按分数排序
            candidates.sort((a, b) => b.score - a.score);
            
            console.log('相似元素:', candidates.map(c => ({
                score: c.score,
                reasons: c.reasons
            })));
            
            return candidates;
        }
        
        // 生成稳定的元素ID - 增强版
        function generateElementId(element) {
            // 策略1: 使用原生ID
            if (element.id) {
                return `id-${element.id}`;
            }
            
            // 策略2: 使用data属性
            if (element.dataset && element.dataset.function) {
                return `data-function-${element.dataset.function}`;
            }
            
            // 策略3: 基于稳定特征生成ID
            const tagName = element.tagName.toLowerCase();
            const className = element.className ? element.className.split(' ')[0] : '';
            const parentClass = element.parentElement ? element.parentElement.className.split(' ')[0] : '';
            
            // 使用位置特征
            const siblings = element.parentElement ? Array.from(element.parentElement.children) : [];
            const index = siblings.indexOf(element);
            const sameTagSiblings = siblings.filter(s => s.tagName === element.tagName);
            const tagIndex = sameTagSiblings.indexOf(element);
            
            // 特殊元素处理
            let specialFeature = '';
            
            // Canvas元素特殊处理
            if (tagName === 'canvas') {
                specialFeature = generateCanvasSignature(element);
            }
            
            // SVG元素特殊处理
            else if (tagName === 'svg') {
                const viewBox = element.getAttribute('viewBox');
                specialFeature = `svg-${viewBox || element.getAttribute('width') || 'auto'}`;
            }
            
            // 图片元素特殊处理
            else if (tagName === 'img') {
                const src = element.src ? element.src.split('/').pop().split('.')[0] : '';
                specialFeature = `img-${src || 'noname'}`;
            }
            
            // 表单元素特殊处理
            else if (['input', 'select', 'textarea', 'button'].includes(tagName)) {
                const type = element.type || tagName;
                const name = element.name || '';
                specialFeature = `${type}-${name}`;
            }
            
            // 文本内容（对于有内容的元素）
            else {
                const textContent = element.textContent ? element.textContent.trim().substring(0, 15) : '';
                if (textContent) {
                    specialFeature = textContent.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '');
                }
            }
            
            // 生成稳定的ID
            const features = [
                tagName,
                className || 'noclass',
                parentClass || 'noparent', 
                `idx${index}`,
                `tag${tagIndex}`,
                specialFeature || 'nofeature'
            ].filter(f => f && f !== '').join('-');
            
            const stableId = features.replace(/[^a-zA-Z0-9\u4e00-\u9fa5-]/g, '-').replace(/-+/g, '-');
            
            console.log('生成元素ID:', {
                element: element,
                tagName,
                className,
                index,
                tagIndex,
                specialFeature,
                finalId: `stable-${stableId}`
            });
            
            return `stable-${stableId}`;
        }

        // 获取元素名称
        function getElementName(element) {
            // 优先级：panel-title > 文本内容 > class > id > 标签名
            const titleElement = element.querySelector('.panel-title, .title, h1, h2, h3, h4, h5, h6');
            if (titleElement && titleElement.textContent.trim()) {
                return titleElement.textContent.trim();
            }
            
            const textContent = element.textContent ? element.textContent.trim().substring(0, 30) : '';
            if (textContent && textContent.length > 3) {
                return textContent;
            }
            
            if (element.id) {
                return `#${element.id}`;
            }
            
            if (element.className) {
                return `.${element.className.split(' ')[0]}`;
            }
            
            return element.tagName.toLowerCase();
        }

        // 获取元素描述
        function getElementDescription(element) {
            const tagName = element.tagName.toLowerCase();
            const className = element.className ? ` (${element.className.split(' ').slice(0, 2).join(' ')})` : '';
            const id = element.id ? ` #${element.id}` : '';
            
            return `${tagName}元素${id}${className}`;
        }

        // 加载批注数据（支持API和本地文件）
        async function loadAnnotations() {
            const statusElement = document.getElementById('annotationStatus');
            
            try {
                // 显示加载状态
                if (statusElement) {
                    statusElement.textContent = '正在加载...';
                    statusElement.style.color = '#2196F3';
                }
                
                // 使用API客户端加载数据
                const annotations = await apiClient.loadAnnotations();
                
                if (annotations && Object.keys(annotations).length > 0) {
                    
                    // 验证并迁移批注数据格式
                    currentAnnotations = validateAndMigrateAnnotations(annotations);
                    
                    // 统计批注数量
                    let totalAnnotations = 0;
                    Object.values(currentAnnotations).forEach(pageAnnotations => {
                        totalAnnotations += Object.keys(pageAnnotations).length;
                    });
                    
                    console.log('=== 批注数据加载成功 ===');
                    console.log('页面数量:', Object.keys(currentAnnotations).length);
                    console.log('总批注数量:', totalAnnotations);
                    console.log('详细批注数据:', currentAnnotations);
                    console.log('当前页面键:', getCurrentPageKey());
                    console.log('所有页面键:', Object.keys(currentAnnotations));
                    
                    // 更新状态显示
                    if (statusElement) {
                        statusElement.textContent = `已加载 (${totalAnnotations}条批注)`;
                        statusElement.style.color = '#4CAF50';
                    }
                } else {
                    console.log('批注文件不存在，创建新的批注数据');
                    currentAnnotations = {};
                    
                    if (statusElement) {
                        statusElement.textContent = '文件不存在';
                        statusElement.style.color = '#ff9800';
                    }
                }
            } catch (error) {
                console.log('批注文件读取失败，创建新的批注数据:', error);
                currentAnnotations = {};
                
                if (statusElement) {
                    statusElement.textContent = '加载失败';
                    statusElement.style.color = '#f44336';
                }
            }
            
            // 更新最后更新时间
            updateLastUpdateTime();
        }
        
        // 调试批注系统
        function debugAnnotationSystem() {
            const pageKey = getCurrentPageKey();
            const pageAnnotations = currentAnnotations[pageKey] || {};
            const elements = pageElements[pageKey] || {};
            
            console.log('=== 批注系统调试信息 ===');
            console.log('当前页面:', pages[currentPageIndex]);
            console.log('当前功能:', currentFunction);
            console.log('页面键:', pageKey);
            console.log('选中元素ID:', selectedElementId);
            console.log('批注模式:', isAnnotationMode);
            console.log('所有批注数据:', currentAnnotations);
            console.log('当前页面批注:', pageAnnotations);
            console.log('当前页面元素:', elements);
            
            // 显示调试信息到批注面板
            const annotationContent = document.getElementById('annotationContent');
            if (annotationContent) {
                annotationContent.innerHTML = `
                    <div class="annotation-item">
                        <div class="annotation-title">🐛 系统调试信息</div>
                        <div style="font-size: 11px; margin-top: 8px; line-height: 1.4;">
                            <div><strong>当前页面:</strong> ${pages[currentPageIndex]}</div>
                            <div><strong>当前功能:</strong> ${currentFunction}</div>
                            <div><strong>页面键:</strong> ${pageKey}</div>
                            <div><strong>选中元素:</strong> ${selectedElementId || '无'}</div>
                            <div><strong>批注模式:</strong> ${isAnnotationMode ? '已开启' : '已关闭'}</div>
                            <hr style="margin: 8px 0; border-color: #404040;">
                            <div><strong>当前页面批注数:</strong> ${Object.keys(pageAnnotations).length}</div>
                            <div><strong>当前页面元素数:</strong> ${Object.keys(elements).length}</div>
                            <div><strong>全部批注数:</strong> ${Object.values(currentAnnotations).reduce((total, page) => total + Object.keys(page).length, 0)}</div>
                            <hr style="margin: 8px 0; border-color: #404040;">
                            <div style="color: #00a8ff;"><strong>当前页面批注列表:</strong></div>
                            ${Object.entries(pageAnnotations).map(([id, annotation]) => `
                                <div style="margin: 2px 0; padding: 4px; background: #333; border-radius: 2px;">
                                    <div style="font-weight: bold;">📝 ${annotation.name}</div>
                                    <div style="font-size: 10px; color: #ccc;">ID: ${id}</div>
                                    <div style="font-size: 10px; color: #ccc;">内容: ${annotation.content.substring(0, 30)}...</div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="margin-top: 8px;">
                            <button onclick="console.clear(); console.log('控制台已清空')" class="nav-button" style="margin: 2px; font-size: 10px;">清空控制台</button>
                            <button onclick="updateElementList()" class="nav-button" style="margin: 2px; font-size: 10px;">刷新列表</button>
                        </div>
                    </div>
                `;
            }
            
            alert('调试信息已输出到控制台和批注面板，请查看！');
        }
        
        // 测试高亮功能
        function testHighlight() {
            console.log('=== 测试高亮功能 ===');
            
            // 创建一个测试高亮框
            clearHighlights();
            
            const iframe = document.getElementById('embeddedFrame');
            const iframeRect = iframe.getBoundingClientRect();
            
            // 在iframe中心创建测试高亮
            const testHighlight = document.createElement('div');
            testHighlight.className = 'highlight-overlay';
            testHighlight.id = 'test-highlight';
            
            testHighlight.style.position = 'fixed';
            testHighlight.style.left = (iframeRect.left + 100) + 'px';
            testHighlight.style.top = (iframeRect.top + 100) + 'px';
            testHighlight.style.width = '200px';
            testHighlight.style.height = '100px';
            testHighlight.style.zIndex = '1000';
            testHighlight.style.border = '5px solid #ff0000';
            testHighlight.style.background = 'rgba(255, 0, 0, 0.5)';
            testHighlight.style.pointerEvents = 'none';
            
            document.body.appendChild(testHighlight);
            
            console.log('测试高亮已创建:', testHighlight);
            console.log('iframe位置:', iframeRect);
            
            // 如果有批注数据，尝试高亮第一个
            const pageKey = getCurrentPageKey();
            const pageAnnotations = currentAnnotations[pageKey] || {};
            const annotationIds = Object.keys(pageAnnotations);
            
            if (annotationIds.length > 0) {
                const firstAnnotationId = annotationIds[0];
                console.log('尝试高亮第一个批注:', firstAnnotationId);
                
                setTimeout(() => {
                    highlightElement(firstAnnotationId);
                }, 2000);
            }
            
            // 5秒后移除测试高亮
            setTimeout(() => {
                if (testHighlight.parentNode) {
                    testHighlight.remove();
                }
            }, 5000);
            
            alert('测试高亮已创建！红色框应该出现在iframe上方。如果有批注，2秒后会尝试高亮第一个批注。');
        }
        
        // 强制刷新批注数据和显示
        async function forceRefreshAnnotations() {
            console.log('=== 强制刷新批注系统 ===');
            
            // 清空当前数据
            currentAnnotations = {};
            pageElements = {};
            selectedElementId = null;
            
            // 重新加载批注数据
            await loadAnnotations();
            
            // 强制更新元素清单
            updateElementList();
            
            // 清空批注面板
            const annotationContent = document.getElementById('annotationContent');
            if (annotationContent) {
                annotationContent.innerHTML = `
                    <div class="annotation-item">
                        <div class="annotation-title">🔄 系统已刷新</div>
                        <div style="margin-top: 8px; color: #4CAF50;">
                            批注数据已重新加载完成！
                        </div>
                    </div>
                `;
            }
            
            console.log('强制刷新完成');
            alert('批注系统已强制刷新！请查看页面元素清单。');
        }

        // 验证和修复批注数据
        async function validateAndFixAnnotations() {
            console.log('=== 开始验证和修复批注数据 ===');
            
            const statusElement = document.getElementById('annotationStatus');
            if (statusElement) {
                statusElement.textContent = '正在修复...';
                statusElement.style.color = '#ff9800';
            }
            
            try {
                const iframe = document.getElementById('embeddedFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                let fixedCount = 0;
                let removedCount = 0;
                const newAnnotations = {};
                
                // 遍历所有批注
                for (const [pageKey, pageAnnotations] of Object.entries(currentAnnotations)) {
                    newAnnotations[pageKey] = {};
                    
                    for (const [elementId, annotation] of Object.entries(pageAnnotations)) {
                        console.log(`检查批注: ${pageKey}/${elementId}`);
                        
                        // 尝试在当前页面中找到对应元素
                        let targetElement = null;
                        
                        // 多策略查找元素
                        targetElement = await findElementByMultipleStrategies(iframeDoc, elementId, annotation);
                        
                        if (targetElement) {
                            // 元素找到了，生成新的稳定ID
                            const newElementId = generateElementId(targetElement);
                            const newSelector = generateElementSelector(targetElement);
                            
                            // 更新批注数据
                            newAnnotations[pageKey][newElementId] = {
                                ...annotation,
                                elementId: newElementId,
                                selector: newSelector,
                                lastValidated: new Date().toLocaleString('zh-CN'),
                                originalElementId: elementId !== newElementId ? elementId : undefined
                            };
                            
                            if (elementId !== newElementId) {
                                console.log(`修复批注: ${elementId} -> ${newElementId}`);
                                fixedCount++;
                            }
                        } else {
                            // 元素找不到，询问是否删除
                            const shouldKeep = confirm(`找不到批注对应的元素:\n\n标题: ${annotation.name}\n内容: ${annotation.content}\n\n是否保留此批注？\n(点击"确定"保留，"取消"删除)`);
                            
                            if (shouldKeep) {
                                // 保留但标记为无效
                                newAnnotations[pageKey][elementId] = {
                                    ...annotation,
                                    status: 'invalid',
                                    lastValidated: new Date().toLocaleString('zh-CN'),
                                    note: '元素未找到，请手动修复'
                                };
                            } else {
                                console.log(`删除无效批注: ${elementId}`);
                                removedCount++;
                            }
                        }
                    }
                }
                
                // 更新批注数据
                currentAnnotations = newAnnotations;
                
                // 保存修复后的数据
                await saveAnnotations();
                await loadAnnotations();
                updateElementList();
                
                // 显示修复结果
                const annotationContent = document.getElementById('annotationContent');
                if (annotationContent) {
                    annotationContent.innerHTML = `
                        <div class="annotation-item">
                            <div class="annotation-title">🔧 批注修复完成</div>
                            <div style="margin-top: 8px; line-height: 1.5;">
                                <div style="color: #4CAF50;">✅ 修复数量: ${fixedCount}</div>
                                <div style="color: #f44336;">❌ 删除数量: ${removedCount}</div>
                                <div style="color: #2196F3;">📊 总计处理: ${fixedCount + removedCount}</div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #404040; font-size: 11px; color: #999;">
                                    修复后的批注使用更稳定的元素标识，能够更准确地定位页面元素。
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                if (statusElement) {
                    statusElement.textContent = `修复完成 (修复${fixedCount}个)`;
                    statusElement.style.color = '#4CAF50';
                }
                
                console.log('批注修复完成:', { fixedCount, removedCount });
                alert(`批注修复完成！\n修复: ${fixedCount} 个\n删除: ${removedCount} 个`);
                
            } catch (error) {
                console.error('批注修复失败:', error);
                
                if (statusElement) {
                    statusElement.textContent = '修复失败';
                    statusElement.style.color = '#f44336';
                }
                
                alert('批注修复失败: ' + error.message);
            }
        }

        // 多策略查找元素 - 增强版
        async function findElementByMultipleStrategies(iframeDoc, elementId, annotation) {
            console.log('多策略查找元素:', elementId, annotation.name);
            
            // 策略1: 直接选择器查找
            if (annotation.selector) {
                try {
                    const element = iframeDoc.querySelector(annotation.selector);
                    if (element) {
                        console.log('策略1成功: 选择器查找');
                        return element;
                    }
                } catch (e) {
                    console.log('选择器无效:', annotation.selector);
                }
            }
            
            // 策略2: ID查找
            if (elementId.startsWith('id-')) {
                const actualId = elementId.substring(3);
                const element = iframeDoc.getElementById(actualId);
                if (element) {
                    console.log('策略2成功: ID查找');
                    return element;
                }
            }
            
            // 策略3: 特殊元素类型查找
            if (elementId.includes('canvas') || annotation.name.toLowerCase().includes('canvas')) {
                console.log('策略3: Canvas元素专门查找');
                const canvasElements = iframeDoc.querySelectorAll('canvas');
                console.log('找到canvas元素数量:', canvasElements.length);
                
                for (const canvas of canvasElements) {
                    // 检查尺寸匹配
                    const sizeMatch = elementId.includes(`${canvas.width}x${canvas.height}`);
                    // 检查位置匹配
                    const rect = canvas.getBoundingClientRect();
                    console.log('Canvas元素信息:', {
                        width: canvas.width,
                        height: canvas.height,
                        rect: rect,
                        parent: canvas.parentElement?.className
                    });
                    
                    // 如果是页面中唯一的canvas或尺寸匹配，优先选择
                    if (canvasElements.length === 1 || sizeMatch) {
                        console.log('策略3成功: Canvas元素匹配');
                        return canvas;
                    }
                }
                
                // 如果有多个canvas，选择第一个
                if (canvasElements.length > 0) {
                    console.log('策略3成功: 选择第一个Canvas');
                    return canvasElements[0];
                }
            }
            
            // 策略4: 稳定ID特征解析查找
            if (elementId.startsWith('stable-')) {
                console.log('策略4: 稳定ID特征解析');
                const features = elementId.substring(7).split('-');
                const [tagName, className, parentClass, ...rest] = features;
                
                console.log('解析的特征:', { tagName, className, parentClass, rest });
                
                let candidates = [];
                
                // 按标签查找
                if (tagName) {
                    candidates = Array.from(iframeDoc.getElementsByTagName(tagName));
                    console.log(`按标签${tagName}找到:`, candidates.length);
                }
                
                // 按类名筛选
                if (className && className !== 'noclass' && candidates.length > 0) {
                    candidates = candidates.filter(el => el.className.includes(className));
                    console.log(`按类名${className}筛选后:`, candidates.length);
                }
                
                // 按父元素类名筛选
                if (parentClass && parentClass !== 'noparent' && candidates.length > 0) {
                    candidates = candidates.filter(el => 
                        el.parentElement && el.parentElement.className.includes(parentClass)
                    );
                    console.log(`按父类名${parentClass}筛选后:`, candidates.length);
                }
                
                // 按位置索引筛选
                const indexMatch = rest.find(f => f.startsWith('idx'));
                if (indexMatch && candidates.length > 1) {
                    const index = parseInt(indexMatch.substring(3));
                    if (!isNaN(index) && index < candidates.length) {
                        const parent = candidates[0].parentElement;
                        if (parent) {
                            const siblings = Array.from(parent.children);
                            if (siblings[index] && candidates.includes(siblings[index])) {
                                candidates = [siblings[index]];
                                console.log(`按索引${index}精确定位`);
                            }
                        }
                    }
                }
                
                if (candidates.length > 0) {
                    console.log('策略4成功: 稳定特征匹配');
                    return candidates[0];
                }
            }
            
            // 策略5: 根据文本内容查找
            if (annotation.name) {
                const cleanName = annotation.name.replace(/[📝🌾🥬⚠️📈📊🌤️]/g, '').trim();
                if (cleanName && cleanName !== 'canvas') { // 排除纯canvas搜索
                    const allElements = iframeDoc.querySelectorAll('*');
                    
                    for (const element of allElements) {
                        const text = element.textContent?.trim();
                        if (text && text.includes(cleanName) && element.children.length === 0) {
                            console.log('策略5成功: 文本内容查找');
                            return element;
                        }
                    }
                }
            }
            
            // 策略6: 类名部分匹配
            const classMatches = elementId.match(/([a-zA-Z-]+)/g);
            if (classMatches) {
                for (const className of classMatches) {
                    if (className.length > 4 && !['stable', 'canvas', 'noclass'].includes(className)) {
                        const elements = iframeDoc.getElementsByClassName(className);
                        if (elements.length > 0) {
                            console.log('策略6成功: 类名匹配');
                            return elements[0];
                        }
                    }
                }
            }
            
            console.log('所有策略都失败了');
            return null;
        }

        // 全面诊断系统
        async function comprehensiveDiagnosis() {
            console.log('🩺 开始全面诊断...');
            
            const annotationContent = document.getElementById('annotationContent');
            const iframe = document.getElementById('embeddedFrame');
            
            // 诊断结果收集
            const diagnosis = {
                iframe: { accessible: false, crossOrigin: false, loaded: false },
                annotations: { total: 0, accessible: 0, broken: 0 },
                elements: { found: 0, missing: 0, virtual: 0 },
                recommendations: []
            };
            
            // 1. iframe访问性诊断
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                if (iframeDoc && iframeDoc.body) {
                    diagnosis.iframe.accessible = true;
                    diagnosis.iframe.loaded = true;
                    console.log('✅ iframe可访问');
                } else {
                    diagnosis.iframe.crossOrigin = true;
                    console.log('❌ iframe跨域限制');
                }
            } catch (error) {
                diagnosis.iframe.crossOrigin = true;
                console.log('❌ iframe访问失败:', error.message);
            }
            
            // 2. 批注数据诊断
            diagnosis.annotations.total = Object.values(currentAnnotations).reduce(
                (total, pageAnnotations) => total + Object.keys(pageAnnotations).length, 0
            );
            
            // 3. 元素定位诊断
            for (const [pageKey, pageAnnotations] of Object.entries(currentAnnotations)) {
                for (const [elementId, annotation] of Object.entries(pageAnnotations)) {
                    try {
                        const canHighlight = await testElementHighlight(elementId, false);
                        if (canHighlight) {
                            diagnosis.annotations.accessible++;
                        } else {
                            diagnosis.annotations.broken++;
                        }
                    } catch (error) {
                        diagnosis.annotations.broken++;
                    }
                }
            }
            
            // 4. 虚拟元素统计
            const pageKey = getCurrentPageKey();
            const pageElements_current = pageElements[pageKey] || {};
            diagnosis.elements.found = Object.keys(pageElements_current).length;
            diagnosis.elements.virtual = Object.values(pageElements_current).filter(el => el.virtual).length;
            diagnosis.elements.missing = diagnosis.annotations.total - diagnosis.annotations.accessible;
            
            // 5. 生成建议
            if (diagnosis.iframe.crossOrigin) {
                diagnosis.recommendations.push('建议使用同域iframe或实现postMessage通信');
            }
            if (diagnosis.annotations.broken > 0) {
                diagnosis.recommendations.push(`发现${diagnosis.annotations.broken}个无法定位的批注，建议运行批注修复`);
            }
            if (diagnosis.elements.virtual > 0) {
                diagnosis.recommendations.push('系统正在使用虚拟元素定位，建议优化元素抓取机制');
            }
            if (diagnosis.annotations.accessible / diagnosis.annotations.total < 0.8) {
                diagnosis.recommendations.push('批注可访问率较低，建议重新抓取页面元素');
            }
            
            // 6. 显示诊断结果
            annotationContent.innerHTML = `
                <div class="annotation-item">
                    <div class="annotation-title">🩺 系统诊断报告</div>
                    <div style="margin-top: 12px; line-height: 1.6;">
                        <h4 style="color: #00a8ff; margin: 8px 0 4px 0;">📱 iframe状态</h4>
                        <div style="font-size: 11px; margin-left: 12px;">
                            <div>• 可访问: ${diagnosis.iframe.accessible ? '✅ 是' : '❌ 否'}</div>
                            <div>• 跨域限制: ${diagnosis.iframe.crossOrigin ? '⚠️ 是' : '✅ 否'}</div>
                            <div>• 已加载: ${diagnosis.iframe.loaded ? '✅ 是' : '❌ 否'}</div>
                        </div>
                        
                        <h4 style="color: #00a8ff; margin: 8px 0 4px 0;">📝 批注状态</h4>
                        <div style="font-size: 11px; margin-left: 12px;">
                            <div>• 总数: ${diagnosis.annotations.total}</div>
                            <div>• 可定位: <span style="color: #4CAF50">${diagnosis.annotations.accessible}</span></div>
                            <div>• 失效: <span style="color: #f44336">${diagnosis.annotations.broken}</span></div>
                            <div>• 成功率: <span style="color: ${diagnosis.annotations.accessible / diagnosis.annotations.total > 0.8 ? '#4CAF50' : '#ff9800'}">${Math.round(diagnosis.annotations.accessible / diagnosis.annotations.total * 100)}%</span></div>
                        </div>
                        
                        <h4 style="color: #00a8ff; margin: 8px 0 4px 0;">🔍 元素状态</h4>
                        <div style="font-size: 11px; margin-left: 12px;">
                            <div>• 已识别: ${diagnosis.elements.found}</div>
                            <div>• 虚拟元素: ${diagnosis.elements.virtual}</div>
                            <div>• 缺失: ${diagnosis.elements.missing}</div>
                        </div>
                        
                        ${diagnosis.recommendations.length > 0 ? `
                        <h4 style="color: #ff9800; margin: 8px 0 4px 0;">💡 优化建议</h4>
                        <div style="font-size: 11px; margin-left: 12px;">
                            ${diagnosis.recommendations.map(rec => `<div>• ${rec}</div>`).join('')}
                        </div>
                        ` : ''}
                        
                        <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #404040;">
                            <button onclick="autoFixIssues()" class="nav-button" style="margin: 2px; font-size: 10px; background: #4CAF50;">自动修复</button>
                            <button onclick="exportDiagnosisReport()" class="nav-button" style="margin: 2px; font-size: 10px; background: #2196F3;">导出报告</button>
                        </div>
                    </div>
                </div>
            `;
            
            console.log('🩺 诊断完成:', diagnosis);
            return diagnosis;
        }
        
        // 测试元素高亮（不显示高亮框）
        async function testElementHighlight(elementId, showHighlight = true) {
            try {
                const pageKey = getCurrentPageKey();
                const elementData = pageElements[pageKey]?.[elementId];
                const annotation = currentAnnotations[pageKey]?.[elementId];
                
                // 虚拟元素总是可以高亮
                if (elementData && elementData.virtual) {
                    if (showHighlight) highlightVirtualElement(elementData);
                    return true;
                }
                
                // 坐标元素可以高亮
                if (elementData && elementData.rect) {
                    if (showHighlight) highlightByCoordinates(elementData);
                    return true;
                }
                
                // 批注信息可以推断
                if (annotation) {
                    if (showHighlight) highlightByAnnotationInfo(annotation, elementId);
                    return true;
                }
                
                // DOM查找
                const iframe = document.getElementById('embeddedFrame');
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const element = await findElementByMultipleStrategies(iframeDoc, elementId, annotation);
                    if (element) {
                        if (showHighlight) {
                            // 创建临时高亮
                            const rect = element.getBoundingClientRect();
                            const iframeRect = iframe.getBoundingClientRect();
                            const scale = parseFloat(iframe.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
                            const left = iframeRect.left + (rect.left * scale);
                            const top = iframeRect.top + (rect.top * scale);
                            const width = rect.width * scale;
                            const height = rect.height * scale;
                            createHighlightOverlay(left, top, width, height, 'DOM定位成功');
                        }
                        return true;
                    }
                } catch (error) {
                    console.log('DOM查找失败:', error);
                }
                
                return false;
            } catch (error) {
                console.log('测试高亮失败:', error);
                return false;
            }
        }
        
        // 测试所有批注
        async function testAllAnnotations() {
            console.log('🧪 开始测试所有批注...');
            
            const results = {
                total: 0,
                success: 0,
                failed: [],
                tested: []
            };
            
            // 遍历所有批注
            for (const [pageKey, pageAnnotations] of Object.entries(currentAnnotations)) {
                for (const [elementId, annotation] of Object.entries(pageAnnotations)) {
                    results.total++;
                    
                    const success = await testElementHighlight(elementId, false);
                    if (success) {
                        results.success++;
                        results.tested.push({
                            id: elementId,
                            name: annotation.name,
                            status: '✅ 成功',
                            page: pageKey
                        });
                    } else {
                        results.failed.push({
                            id: elementId,
                            name: annotation.name,
                            status: '❌ 失败',
                            page: pageKey
                        });
                    }
                    
                    // 给UI一些时间更新
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            // 显示测试结果
            const annotationContent = document.getElementById('annotationContent');
            annotationContent.innerHTML = `
                <div class="annotation-item">
                    <div class="annotation-title">🧪 批注测试报告</div>
                    <div style="margin-top: 12px; line-height: 1.5;">
                        <div style="font-size: 12px; margin-bottom: 8px;">
                            <span style="color: #4CAF50">成功: ${results.success}</span> / 
                            <span style="color: #f44336">失败: ${results.failed.length}</span> / 
                            <span style="color: #2196F3">总计: ${results.total}</span>
                        </div>
                        
                        ${results.failed.length > 0 ? `
                        <h4 style="color: #f44336; margin: 8px 0 4px 0;">❌ 失败项目</h4>
                        <div style="max-height: 150px; overflow-y: auto; font-size: 10px;">
                            ${results.failed.map(item => `
                                <div style="margin: 2px 0; padding: 4px; background: rgba(244, 67, 54, 0.1); border-radius: 2px;">
                                    <strong>${item.name}</strong><br>
                                    <span style="color: #999;">ID: ${item.id}</span><br>
                                    <span style="color: #999;">页面: ${item.page}</span>
                                </div>
                            `).join('')}
                        </div>
                        ` : ''}
                        
                        <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #404040;">
                            <button onclick="highlightNextFailed()" class="nav-button" style="margin: 2px; font-size: 10px;">逐个测试失败项</button>
                            ${results.failed.length > 0 ? `
                            <button onclick="fixFailedAnnotations()" class="nav-button" style="margin: 2px; font-size: 10px; background: #ff5722;">修复失败项</button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            console.log('🧪 测试完成:', results);
            
            // 存储测试结果供其他功能使用
            window.lastTestResults = results;
            
            alert(`批注测试完成！\n成功: ${results.success}\n失败: ${results.failed.length}\n总计: ${results.total}`);
        }

        // 测试新的精确抓取系统
        async function testNewCaptureSystem() {
            console.log('🎯 测试精确抓取系统...');
            
            const annotationContent = document.getElementById('annotationContent');
            
            annotationContent.innerHTML = `
                <div class="annotation-item">
                    <div class="annotation-title">🎯 精确抓取系统测试</div>
                    <div style="margin-top: 12px; line-height: 1.5;">
                        <div style="background: rgba(0, 168, 255, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 12px;">
                            <h4 style="color: #00a8ff; margin: 0 0 8px 0;">测试说明</h4>
                            <div style="font-size: 12px;">
                                1. 开启批注模式<br>
                                2. 点击页面中的任意元素<br>
                                3. 系统会自动生成精确的元素签名<br>
                                4. 立即验证定位准确性<br>
                                5. 显示详细的抓取信息
                            </div>
                        </div>
                        
                        <div style="margin: 12px 0;">
                            <button onclick="toggleAnnotationMode()" class="nav-button" style="background: #4CAF50;">
                                ${isAnnotationMode ? '✅ 批注模式已开启' : '🎯 开启批注模式'}
                            </button>
                        </div>
                        
                        <div style="background: rgba(255, 193, 7, 0.1); padding: 10px; border-radius: 6px;">
                            <h4 style="color: #ffc107; margin: 0 0 8px 0;">新系统特性</h4>
                            <div style="font-size: 11px;">
                                • 🎯 多重选择器生成 (Primary, XPath, CSS, Unique)<br>
                                • 📏 精确位置记录 (绝对+相对+索引)<br>
                                • 🧬 元素特征签名 (属性+样式+内容)<br>
                                • 🔍 5种重定位策略<br>
                                • ✅ 实时验证匹配度 (100分制)<br>
                                • 🔄 智能容错和降级
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // 显示元素签名详情
        function showElementSignatures() {
            console.log('📋 显示元素签名...');
            
            const pageKey = getCurrentPageKey();
            const pageElements_current = pageElements[pageKey] || {};
            const annotations = currentAnnotations[pageKey] || {};
            
            const annotationContent = document.getElementById('annotationContent');
            
            if (Object.keys(pageElements_current).length === 0) {
                annotationContent.innerHTML = `
                    <div class="annotation-item">
                        <div class="annotation-title">📋 元素签名查看器</div>
                        <div style="margin-top: 12px; text-align: center; color: #999;">
                            <div style="font-size: 48px; margin-bottom: 10px;">📝</div>
                            <div>暂无元素签名数据</div>
                            <div style="margin-top: 8px; font-size: 12px;">
                                请先创建批注以生成元素签名
                            </div>
                        </div>
                    </div>
                `;
                return;
            }
            
            const signatures = Object.entries(pageElements_current).map(([elementId, signature]) => {
                const annotation = annotations[elementId];
                const signatureData = signature.basic ? signature : null; // 检查是否是新格式
                
                return {
                    elementId,
                    signature: signatureData,
                    annotation,
                    hasAnnotation: !!annotation,
                    isNewFormat: !!signatureData
                };
            });
            
            annotationContent.innerHTML = `
                <div class="annotation-item">
                    <div class="annotation-title">📋 元素签名详情</div>
                    <div style="margin-top: 12px; line-height: 1.4;">
                        <div style="margin-bottom: 12px; font-size: 12px;">
                            <span style="color: #4CAF50">新格式: ${signatures.filter(s => s.isNewFormat).length}</span> / 
                            <span style="color: #ff9800">旧格式: ${signatures.filter(s => !s.isNewFormat).length}</span> / 
                            <span style="color: #2196F3">总计: ${signatures.length}</span>
                        </div>
                        
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${signatures.map(item => `
                                <div style="margin: 8px 0; padding: 8px; background: ${item.isNewFormat ? 'rgba(76, 175, 80, 0.1)' : 'rgba(255, 152, 0, 0.1)'}; border-radius: 4px; border-left: 3px solid ${item.isNewFormat ? '#4CAF50' : '#ff9800'};">
                                    <div style="font-weight: bold; margin-bottom: 4px;">
                                        ${item.hasAnnotation ? '📝' : '🔍'} ${item.annotation?.name || item.elementId}
                                    </div>
                                    
                                    ${item.isNewFormat ? `
                                    <div style="font-size: 10px; color: #ccc;">
                                        <div><strong>标签:</strong> ${item.signature.basic.tagName}</div>
                                        <div><strong>ID:</strong> ${item.signature.basic.id || 'none'}</div>
                                        <div><strong>类名:</strong> ${item.signature.basic.className || 'none'}</div>
                                        <div><strong>层级深度:</strong> ${item.signature.hierarchy.depth}</div>
                                        <div><strong>选择器数量:</strong> ${Object.keys(item.signature.selectors).length}</div>
                                        <div><strong>位置索引:</strong> ${item.signature.positioning.siblingIndex.index}/${item.signature.positioning.siblingIndex.total}</div>
                                        <div><strong>文本内容:</strong> ${item.signature.basic.textContent ? '"' + item.signature.basic.textContent.substring(0, 20) + '..."' : 'none'}</div>
                                    </div>
                                    ` : `
                                    <div style="font-size: 10px; color: #ff9800;">
                                        旧格式数据 - 建议运行批注修复升级
                                    </div>
                                    `}
                                    
                                    <div style="margin-top: 6px;">
                                        <button onclick="testSignatureRelocation('${item.elementId}')" class="nav-button" style="font-size: 9px; padding: 2px 6px;">测试定位</button>
                                        ${item.isNewFormat ? `
                                        <button onclick="showDetailedSignature('${item.elementId}')" class="nav-button" style="font-size: 9px; padding: 2px 6px; margin-left: 4px;">详细信息</button>
                                        ` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #404040;">
                            <button onclick="upgradeAllSignatures()" class="nav-button" style="font-size: 10px; background: #ff9800;">升级旧格式签名</button>
                            <button onclick="exportSignatures()" class="nav-button" style="font-size: 10px; margin-left: 6px; background: #2196F3;">导出签名数据</button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // 测试签名重定位
        async function testSignatureRelocation(elementId) {
            console.log('🔍 测试签名重定位:', elementId);
            
            try {
                const iframe = document.getElementById('embeddedFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                const pageKey = getCurrentPageKey();
                const signature = pageElements[pageKey]?.[elementId];
                
                if (!signature) {
                    alert('签名数据不存在');
                    return;
                }
                
                if (!signature.basic) {
                    alert('这是旧格式签名，请先升级');
                    return;
                }
                
                const startTime = performance.now();
                const foundElement = relocateElementBySignature(signature, iframeDoc);
                const endTime = performance.now();
                
                const duration = Math.round(endTime - startTime);
                
                if (foundElement) {
                    // 高亮找到的元素
                    highlightElement(elementId);
                    
                    // 验证匹配度
                    const validation = signature.validate(foundElement);
                    
                    alert(`🎯 重定位成功！\n\n` +
                          `耗时: ${duration}ms\n` +
                          `匹配分数: ${validation.score}/100\n` +
                          `置信度: ${Math.round(validation.confidence * 100)}%\n` +
                          `匹配原因: ${validation.reasons.join(', ')}`);
                } else {
                    alert(`❌ 重定位失败\n\n耗时: ${duration}ms\n请检查元素是否仍然存在于页面中`);
                }
                
            } catch (error) {
                console.error('测试重定位失败:', error);
                alert('测试失败: ' + error.message);
            }
        }
        
        // 显示详细签名信息
        function showDetailedSignature(elementId) {
            const pageKey = getCurrentPageKey();
            const signature = pageElements[pageKey]?.[elementId];
            
            if (!signature || !signature.basic) {
                alert('签名数据不存在或格式错误');
                return;
            }
            
            const details = {
                '基础信息': signature.basic,
                '层级路径': signature.hierarchy,
                '属性特征': signature.attributes,
                '位置信息': signature.positioning,
                '样式特征': signature.styleFeatures,
                '内容特征': signature.contentFeatures,
                '选择器列表': signature.selectors
            };
            
            let output = `📋 元素签名详细信息\n\nID: ${signature.id}\n时间戳: ${new Date(signature.timestamp).toLocaleString()}\n\n`;
            
            for (let [category, data] of Object.entries(details)) {
                output += `${category}:\n${JSON.stringify(data, null, 2)}\n\n`;
            }
            
            console.log('详细签名信息:', signature);
            
            // 创建一个可复制的弹窗
            const textarea = document.createElement('textarea');
            textarea.value = output;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            
            alert('📋 详细签名信息已复制到剪贴板！\n也可以在控制台查看完整数据。');
        }

        // 保存批注数据
        async function saveAnnotations() {
            try {
                // 使用API客户端保存数据
                const success = await apiClient.saveAnnotations(currentAnnotations);
                
                if (success && CURRENT_ENV.enableRealTimeSync) {
                    console.log('✅ 批注数据已保存到服务器');
                } else {
                    console.log('✅ 批注数据已导出到本地');
                }
                
                return success;
            } catch (error) {
                console.error('保存批注数据失败:', error);
                return false;
            }
        }

        // 通过下载方式保存批注数据
        function downloadAnnotations() {
            // 验证和清理批注数据
            const cleanedAnnotations = cleanAnnotationsForSave(currentAnnotations);
            
            const dataStr = JSON.stringify(cleanedAnnotations, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            
            // 使用时间戳命名文件
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `annotations-${timestamp}.json`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('✅ 批注数据已导出:', `annotations-${timestamp}.json`);
        }

        // 验证并迁移批注数据格式
        function validateAndMigrateAnnotations(annotations) {
            console.log('🔄 开始验证和迁移批注数据格式...');
            const migrated = {};
            
            Object.keys(annotations).forEach(pageKey => {
                migrated[pageKey] = {};
                
                Object.keys(annotations[pageKey]).forEach(elementId => {
                    const annotation = annotations[pageKey][elementId];
                    
                    // 检查是否是新格式
                    const hasSmartSelector = annotation.targetInfo?.smartSelector;
                    const hasElementFingerprint = annotation.targetInfo?.elementFingerprint;
                    
                    if (hasSmartSelector && hasElementFingerprint) {
                        // 已经是新格式，直接使用
                        console.log('✅ 新格式批注:', elementId);
                        migrated[pageKey][elementId] = annotation;
                    } else {
                        // 旧格式，需要迁移
                        console.log('🔄 迁移旧格式批注:', elementId);
                        migrated[pageKey][elementId] = migrateOldAnnotation(annotation, elementId);
                    }
                });
            });
            
            console.log('✅ 批注数据格式迁移完成');
            return migrated;
        }
        
        // 迁移旧格式批注到新格式
        function migrateOldAnnotation(oldAnnotation, elementId) {
            console.log('🔄 迁移批注:', elementId, oldAnnotation);
            
            // 从旧的selector生成智能选择器
            const oldSelector = oldAnnotation.targetInfo?.selector || '';
            const smartSelector = oldSelector || 'div'; // 如果没有选择器，使用默认值
            
            // 从旧数据生成元素指纹
            const elementFingerprint = {
                tagName: 'DIV', // 默认值，实际应该从选择器推断
                className: extractClassFromSelector(oldSelector),
                textContent: oldAnnotation.name || '', // 使用批注名称作为文本内容
                attributes: {},
                position: {
                    offsetLeft: oldAnnotation.targetInfo?.pageX || 0,
                    offsetTop: oldAnnotation.targetInfo?.pageY || 0,
                    offsetWidth: oldAnnotation.targetInfo?.width || 0,
                    offsetHeight: oldAnnotation.targetInfo?.height || 0
                },
                chartType: null
            };
            
            // 生成备用选择器
            const fallbackSelector = extractClassFromSelector(oldSelector) || 'div';
            
            return {
                name: oldAnnotation.name || '',
                content: oldAnnotation.content || '',
                timestamp: oldAnnotation.timestamp || new Date().toLocaleString('zh-CN'),
                elementId: elementId,
                targetInfo: {
                    smartSelector: smartSelector,
                    elementFingerprint: elementFingerprint,
                    fallbackSelector: fallbackSelector,
                    textContent: oldAnnotation.name || '',
                    pageUrl: oldAnnotation.targetInfo?.pageUrl || '',
                    timestamp: oldAnnotation.targetInfo?.timestamp || new Date().toISOString()
                }
            };
        }
        
        // 从选择器中提取类名
        function extractClassFromSelector(selector) {
            if (!selector) return '';
            
            // 提取最后一个类名
            const classMatches = selector.match(/\.([a-zA-Z0-9_-]+)/g);
            if (classMatches && classMatches.length > 0) {
                return classMatches[classMatches.length - 1].substring(1); // 去掉点号
            }
            
            return '';
        }

        // 清理批注数据用于保存
        function cleanAnnotationsForSave(annotations) {
            const cleaned = {};
            
            Object.keys(annotations).forEach(pageKey => {
                cleaned[pageKey] = {};
                
                Object.keys(annotations[pageKey]).forEach(elementId => {
                    const annotation = annotations[pageKey][elementId];
                    
                    // 创建清理后的批注对象
                    cleaned[pageKey][elementId] = {
                        name: annotation.name || '',
                        content: annotation.content || '',
                        timestamp: annotation.timestamp || new Date().toLocaleString('zh-CN'),
                        elementId: elementId,
                        targetInfo: {
                            smartSelector: annotation.targetInfo?.smartSelector || '',
                            elementFingerprint: {
                                tagName: annotation.targetInfo?.elementFingerprint?.tagName || '',
                                className: annotation.targetInfo?.elementFingerprint?.className || '',
                                textContent: annotation.targetInfo?.elementFingerprint?.textContent || '',
                                attributes: annotation.targetInfo?.elementFingerprint?.attributes || {},
                                position: annotation.targetInfo?.elementFingerprint?.position || {
                                    offsetLeft: 0,
                                    offsetTop: 0,
                                    offsetWidth: 0,
                                    offsetHeight: 0
                                },
                                chartType: annotation.targetInfo?.elementFingerprint?.chartType || null
                            },
                            fallbackSelector: annotation.targetInfo?.fallbackSelector || '',
                            textContent: annotation.targetInfo?.textContent || '',
                            pageUrl: annotation.targetInfo?.pageUrl || '',
                            timestamp: annotation.targetInfo?.timestamp || new Date().toISOString()
                        }
                    };
                });
            });
            
            return cleaned;
        }

        // 自动检测当前激活的功能页面
        function detectCurrentFunction() {
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) {
                console.warn('无法访问iframe，使用默认功能');
                return currentFunction;
            }
            
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (!iframeDoc) {
                console.warn('无法访问iframe文档，使用默认功能');
                return currentFunction;
            }
            
            try {
                // 查找激活的主功能按钮
                const activeMainBtn = iframeDoc.querySelector('.main-switch-btn.active');
                if (activeMainBtn) {
                    const detectedFunction = activeMainBtn.getAttribute('data-function');
                    if (detectedFunction && detectedFunction !== currentFunction) {
                        console.log(`🔄 检测到页面功能变化: ${currentFunction} → ${detectedFunction}`);
                        currentFunction = detectedFunction;
                        
                        // 更新页面元素清单和系统状态
                        setTimeout(() => {
                            updateElementList();
                            updateSystemStatus();
                        }, 500);
                    }
                    return detectedFunction;
                }
                
                // 如果没有找到激活按钮，尝试从URL或页面内容推断
                const url = iframe.contentWindow.location.href;
                if (url.includes('growth-analysis')) {
                    return 'growth-analysis';
                } else if (url.includes('yield-estimation')) {
                    return 'yield-estimation';
                } else if (url.includes('weather-monitoring')) {
                    return 'weather-monitoring';
                } else if (url.includes('disaster-monitoring')) {
                    return 'disaster-monitoring';
                } else {
                    return 'crop-distribution'; // 默认值
                }
            } catch (error) {
                console.warn('检测当前功能时出错:', error);
                return currentFunction;
            }
        }

        // 获取当前页面和功能的唯一标识
        function getCurrentPageKey() {
            // 先检测当前实际的功能状态
            const detectedFunction = detectCurrentFunction();
            const currentPage = pages[currentPageIndex];
            return `${currentPage}-${detectedFunction}`;
        }

        // 切换到指定功能页面
        function switchToFunction(targetFunction) {
            console.log(`🔄 切换到功能页面: ${targetFunction}`);
            
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) {
                console.error('无法访问iframe');
                return;
            }
            
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                if (!iframeDoc) {
                    console.error('无法访问iframe文档');
                    return;
                }
                
                // 查找目标功能按钮
                const targetBtn = iframeDoc.querySelector(`[data-function="${targetFunction}"]`);
                if (targetBtn) {
                    // 移除当前激活状态
                    const currentActiveBtn = iframeDoc.querySelector('.main-switch-btn.active');
                    if (currentActiveBtn) {
                        currentActiveBtn.classList.remove('active');
                    }
                    
                    // 激活目标按钮
                    targetBtn.classList.add('active');
                    
                    // 更新currentFunction变量
                    currentFunction = targetFunction;
                    
                    // 触发点击事件（如果有相关的JavaScript逻辑）
                    targetBtn.click();
                    
                    // 延迟更新元素清单和系统状态
                    setTimeout(() => {
                        updateElementList();
                        updateSystemStatus();
                        console.log(`✅ 已切换到 ${targetFunction} 页面`);
                    }, 500);
                } else {
                    console.error(`找不到功能按钮: ${targetFunction}`);
                    alert(`无法找到 "${targetFunction}" 功能按钮`);
                }
            } catch (error) {
                console.error('切换功能页面时出错:', error);
                alert('切换页面失败: ' + error.message);
            }
        }

        // 启动页面状态监听
        function startPageStateMonitoring() {
            console.log('🔍 启动页面状态监听器');
            
            // 定期检测页面状态变化
            setInterval(() => {
                try {
                    const iframe = document.getElementById('embeddedFrame');
                    if (iframe && iframe.contentWindow && iframe.contentDocument) {
                        detectCurrentFunction();
                    }
                } catch (error) {
                    console.warn('页面状态检测失败:', error);
                }
            }, 2000); // 每2秒检测一次
            
            // 监听iframe的点击事件（如果可能）
            try {
                const iframe = document.getElementById('embeddedFrame');
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.addEventListener('click', () => {
                        // 延迟检测，等待点击事件完成
                        setTimeout(() => {
                            detectCurrentFunction();
                        }, 300);
                    });
                }
            } catch (error) {
                console.warn('无法监听iframe点击事件:', error);
            }
        }

        // 更新批注导航状态
        function updateAnnotationNavigation() {
            const detectedFunction = detectCurrentFunction();
            const currentPageKey = getCurrentPageKey();
            const currentPageAnnotations = currentAnnotations[currentPageKey] || {};
            
            // 更新当前页面批注列表
            currentPageAnnotationList = Object.keys(currentPageAnnotations);
            
            const navigationDiv = document.getElementById('annotationNavigation');
            const prevBtn = document.getElementById('prevAnnotationBtn');
            const nextBtn = document.getElementById('nextAnnotationBtn');
            const counter = document.getElementById('annotationCounter');
            
            if (currentPageAnnotationList.length > 0) {
                // 有批注时显示导航
                navigationDiv.style.display = 'block';
                
                // 确保当前索引有效
                if (selectedElementId) {
                    const selectedIndex = currentPageAnnotationList.indexOf(selectedElementId);
                    if (selectedIndex !== -1) {
                        currentAnnotationIndex = selectedIndex;
                    }
                } else if (currentAnnotationIndex >= currentPageAnnotationList.length) {
                    currentAnnotationIndex = 0;
                }
                
                // 更新计数器
                counter.textContent = `${currentAnnotationIndex + 1}/${currentPageAnnotationList.length}`;
                
                // 更新按钮状态
                const hasMultiple = currentPageAnnotationList.length > 1;
                prevBtn.disabled = !hasMultiple || currentAnnotationIndex === 0;
                nextBtn.disabled = !hasMultiple || currentAnnotationIndex === currentPageAnnotationList.length - 1;
                
                // 设置按钮样式
                prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
                nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
                prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';
                nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';
                
            } else {
                // 没有批注时显示空状态导航
                navigationDiv.style.display = 'block';
                counter.textContent = '0/0';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                prevBtn.style.opacity = '0.3';
                nextBtn.style.opacity = '0.3';
                prevBtn.style.cursor = 'not-allowed';
                nextBtn.style.cursor = 'not-allowed';
            }
        }

        // 导航到上一个批注
        function navigateToPreviousAnnotation() {
            if (currentPageAnnotationList.length === 0) return;
            
            currentAnnotationIndex = Math.max(0, currentAnnotationIndex - 1);
            const targetElementId = currentPageAnnotationList[currentAnnotationIndex];
            
            console.log(`🔼 导航到上一个批注: ${targetElementId} (${currentAnnotationIndex + 1}/${currentPageAnnotationList.length})`);
            
            // 选中并高亮目标批注
            selectElementFromAnnotation(detectCurrentFunction(), targetElementId);
        }

        // 导航到下一个批注
        function navigateToNextAnnotation() {
            if (currentPageAnnotationList.length === 0) return;
            
            currentAnnotationIndex = Math.min(currentPageAnnotationList.length - 1, currentAnnotationIndex + 1);
            const targetElementId = currentPageAnnotationList[currentAnnotationIndex];
            
            console.log(`🔽 导航到下一个批注: ${targetElementId} (${currentAnnotationIndex + 1}/${currentPageAnnotationList.length})`);
            
            // 选中并高亮目标批注
            selectElementFromAnnotation(detectCurrentFunction(), targetElementId);
        }

        // 设置键盘快捷键
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                // 只在非输入元素时响应快捷键
                if (event.target.tagName === 'INPUT' || 
                    event.target.tagName === 'TEXTAREA' || 
                    event.target.contentEditable === 'true') {
                    return;
                }
                
                // 上一个批注: 左箭头或 J 键
                if (event.key === 'ArrowLeft' || event.key === 'j' || event.key === 'J') {
                    event.preventDefault();
                    navigateToPreviousAnnotation();
                }
                
                // 下一个批注: 右箭头或 K 键
                if (event.key === 'ArrowRight' || event.key === 'k' || event.key === 'K') {
                    event.preventDefault();
                    navigateToNextAnnotation();
                }
                
                console.log('键盘快捷键:', event.key);
            });
            
            console.log('🎹 键盘快捷键已设置: ← → J K 键可切换批注');
        }

        // 抓取页面元素
        function extractPageElements(iframeDoc) {
            const pageKey = getCurrentPageKey();
            pageElements[pageKey] = {};

            try {
                // 查找所有包含panel-header的元素
                const panelHeaders = iframeDoc.querySelectorAll('.panel-header, [class*="panel-title"], [class*="title"]');
                
                panelHeaders.forEach((element, index) => {
                    const titleElement = element.querySelector('.panel-title') || element;
                    const title = titleElement.textContent.trim();
                    
                    if (title) {
                        const elementId = `element-${index}`;
                        const rect = element.getBoundingClientRect();
                        
                        pageElements[pageKey][elementId] = {
                            id: elementId,
                            name: title,
                            desc: `页面元素: ${element.className}`,
                            element: element,
                            rect: {
                                top: rect.top,
                                left: rect.left,
                                width: rect.width,
                                height: rect.height
                            },
                            selector: generateElementSelector(element)
                        };
                    }
                });

                // 查找其他重要元素
                const otherElements = iframeDoc.querySelectorAll('.widget, .chart, .map, .button, [id], [class*="btn"]');
                otherElements.forEach((element, index) => {
                    const elementId = `other-${index}`;
                    if (!pageElements[pageKey][elementId]) {
                        const name = element.id || element.className.split(' ')[0] || element.tagName;
                        const rect = element.getBoundingClientRect();
                        
                        if (rect.width > 50 && rect.height > 20) { // 过滤太小的元素
                            pageElements[pageKey][elementId] = {
                                id: elementId,
                                name: name,
                                desc: `${element.tagName.toLowerCase()}元素`,
                                element: element,
                                rect: {
                                    top: rect.top,
                                    left: rect.left,
                                    width: rect.width,
                                    height: rect.height
                                },
                                selector: generateElementSelector(element)
                            };
                        }
                    }
                });

                updateElementList();
            } catch (error) {
                console.log('抓取页面元素失败:', error);
            }
        }

        // 生成精确的元素选择器 - 改进版
        function generateElementSelector(element) {
            // 策略1: 优先使用ID选择器
            if (element.id) {
                return `#${element.id}`;
            }
            
            // 策略2: 使用data属性
            if (element.dataset && element.dataset.function) {
                return `[data-function="${element.dataset.function}"]`;
            }
            
            // 策略3: 生成复合选择器路径
            const selectorParts = [];
            let currentElement = element;
            let depth = 0;
            const maxDepth = 4;
            
            while (currentElement && currentElement !== document.body && depth < maxDepth) {
                let selector = currentElement.nodeName.toLowerCase();
                
                // 添加ID（如果存在）
                if (currentElement.id) {
                    selector += `#${currentElement.id}`;
                    selectorParts.unshift(selector);
                    break; // ID是唯一的，可以停止
                }
                
                // 添加重要的类名
                if (currentElement.className) {
                    const classes = currentElement.className.split(' ').filter(cls => 
                        cls && !cls.includes('active') && !cls.includes('hover')
                    );
                    if (classes.length > 0) {
                        selector += '.' + classes.slice(0, 2).join('.');
                    }
                }
                
                // 添加nth-child以提高精确性
                const siblings = currentElement.parentElement ? 
                    Array.from(currentElement.parentElement.children).filter(
                        sibling => sibling.tagName === currentElement.tagName
                    ) : [];
                    
                if (siblings.length > 1) {
                    const index = siblings.indexOf(currentElement) + 1;
                    selector += `:nth-child(${index})`;
                }
                
                selectorParts.unshift(selector);
                currentElement = currentElement.parentElement;
                depth++;
            }
            
            // 策略4: 基于文本内容的备用选择器
            const textContent = element.textContent ? element.textContent.trim() : '';
            if (textContent && textContent.length < 50) {
                selectorParts.push(`[textContent*="${textContent.substring(0, 20)}"]`);
            }
            
            const finalSelector = selectorParts.join(' > ');
            console.log('生成的选择器:', finalSelector);
            return finalSelector;
        }

        // 更新页面元素清单
        function updateElementList() {
            const elementList = document.getElementById('elementList');
            const currentPage = pages[currentPageIndex];
            
            // 收集所有相关功能的批注
            const allRelatedAnnotations = {};
            const functionKeys = Object.keys(functionConfigs);
            
            functionKeys.forEach(funcKey => {
                const pageKey = `${currentPage}-${funcKey}`;
                const pageAnnotations = currentAnnotations[pageKey] || {};
                if (Object.keys(pageAnnotations).length > 0) {
                    allRelatedAnnotations[funcKey] = {
                        title: functionConfigs[funcKey].title,
                        annotations: pageAnnotations
                    };
                }
            });
            
            console.log('=== 更新元素清单 ===');
            console.log('当前页面:', currentPage);
            console.log('当前功能:', currentFunction);
            console.log('功能键列表:', functionKeys);
            console.log('所有批注数据:', currentAnnotations);
            console.log('相关功能批注:', allRelatedAnnotations);
            console.log('找到的批注数量:', Object.keys(allRelatedAnnotations).length);
            
            // 生成按功能分组的批注显示
            let htmlContent = '';
            
            // 获取当前页面的功能键
            const detectedFunction = detectCurrentFunction();
            const currentPageKey = getCurrentPageKey();
            const currentFunctionAnnotations = currentAnnotations[currentPageKey] || {};
            
            if (Object.keys(allRelatedAnnotations).length === 0) {
                // 检查是否是因为当前功能页面没有批注数据
                const functionTitle = functionConfigs[detectedFunction]?.title || detectedFunction;
                
                htmlContent = `
                    <div style="text-align: center; color: #999; padding: 20px;">
                        <div style="font-size: 48px; margin-bottom: 10px;">📝</div>
                        <div style="margin-bottom: 8px;">当前页面：${functionTitle}</div>
                        <div style="margin-bottom: 12px;">暂无批注内容</div>
                        <div style="font-size: 12px; color: #666; line-height: 1.4;">
                            💡 提示：<br>
                            • 目前仅有 "作物分布" 页面的批注数据<br>
                            • 其他页面的批注正在完善中<br>
                            • 您可以开启批注模式为当前页面添加批注
                        </div>
                        <div style="margin-top: 12px;">
                            <button onclick="switchToFunction('crop-distribution')" 
                                    style="background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                📋 查看作物分布批注
                            </button>
                        </div>
                        <div style="margin-top: 8px; font-size: 12px;">
                            开启批注模式，点击页面元素即可添加批注
                        </div>
                    </div>
                `;
            } else {
                // 只显示当前功能页面的批注
                const currentPageAnnotations = currentAnnotations[currentPageKey] || {};
                
                // 直接显示当前页面的批注，不要包装容器
                if (Object.keys(currentPageAnnotations).length > 0) {
                    Object.entries(currentPageAnnotations).forEach(([elementId, annotation]) => {
                        const isSelected = selectedElementId === elementId;
                        htmlContent += `
                            <div class="element-item ${isSelected ? 'active' : ''}" 
                                 onclick="selectElementFromAnnotation('${detectedFunction}', '${elementId}')" 
                                 data-element-id="${elementId}"
                                 style="margin: 4px 0; border: 1px solid #606060; border-radius: 4px; padding: 6px 8px; cursor: pointer; transition: all 0.2s;">
                                <div class="element-name" style="font-size: 11px; font-weight: bold; margin-bottom: 2px;">
                                    📝 ${annotation.name}
                                </div>
                                <div class="element-desc" style="font-size: 10px; color: #ccc; line-height: 1.3;">
                                    ${annotation.content ? annotation.content.substring(0, 80) + (annotation.content.length > 80 ? '...' : '') : '无描述'}
                                </div>
                                <div style="font-size: 9px; color: #999; margin-top: 4px;">
                                    ${annotation.timestamp}
                                </div>
                            </div>
                        `;
                    });
                } else {
                    // 当前页面没有批注时的提示
                    const functionTitle = functionConfigs[detectedFunction]?.title || detectedFunction;
                    htmlContent = `
                        <div style="text-align: center; color: #999; padding: 20px;">
                            <div style="font-size: 48px; margin-bottom: 10px;">📝</div>
                            <div style="margin-bottom: 8px;">当前页面：${functionTitle}</div>
                            <div style="margin-bottom: 12px;">暂无批注内容</div>
                            <div style="font-size: 12px; color: #666; line-height: 1.4;">
                                💡 提示：<br>
                                • 目前仅有 "作物分布" 页面的批注数据<br>
                                • 其他页面的批注正在完善中<br>
                                • 您可以开启批注模式为当前页面添加批注
                            </div>
                            <div style="margin-top: 12px;">
                                <button onclick="switchToFunction('crop-distribution')" 
                                        style="background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    📋 查看作物分布批注
                                </button>
                            </div>
                            <div style="margin-top: 8px; font-size: 12px;">
                                开启批注模式，点击页面元素即可添加批注
                            </div>
                        </div>
                    `;
                }
                
            }
            
            elementList.innerHTML = htmlContent;
            
            // 更新批注导航状态
            updateAnnotationNavigation();
        }
        
        // 从批注选择元素（跨功能）
        async function selectElementFromAnnotation(functionKey, elementId) {
            console.log('selectElementFromAnnotation 被调用:', { functionKey, elementId, currentFunction });
            
            // 如果不是当前功能，切换到对应功能
            if (functionKey !== currentFunction) {
                console.log('切换功能从', currentFunction, '到', functionKey);
                currentFunction = functionKey;
                await updatePageContentByFunction(functionKey);
                
                // 等待iframe加载完成
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // 选择元素
            selectedElementId = elementId;
            console.log('选中元素ID:', selectedElementId);
            
            // 检查批注数据是否存在
            const pageKey = getCurrentPageKey();
            const pageAnnotations = currentAnnotations[pageKey] || {};
            const annotation = pageAnnotations[elementId];
            
            console.log('页面键:', pageKey);
            console.log('页面批注:', pageAnnotations);
            console.log('目标批注:', annotation);
            
            if (!annotation) {
                console.error('找不到批注数据:', elementId);
                alert('批注数据不存在，请重新加载批注数据');
                return;
            }
            
            // 显示批注内容
            updateAnnotationDisplay(elementId);
            
            // 检查并显示弹窗（如果需要）
            await ensureModalVisibility(annotation);
            
            // 使用增强的高亮系统
            const highlightSuccess = enhancedHighlightElement(annotation);
            if (!highlightSuccess) {
                console.warn('增强高亮失败，尝试传统高亮方法');
                
                // 备用：传统高亮方法
                try {
                    const iframe = document.getElementById('embeddedFrame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    
                    // 尝试多种方式查找元素
                    let targetElement = null;
                
                // 方式1: 通过ID查找
                if (elementId.startsWith('id-')) {
                    const actualId = elementId.substring(3);
                    targetElement = iframeDoc.getElementById(actualId);
                }
                
                // 方式2: 通过类名查找
                if (!targetElement && elementId.includes('-')) {
                    const parts = elementId.split('-');
                    if (parts.length >= 2) {
                        const className = parts[1];
                        const elements = iframeDoc.getElementsByClassName(className);
                        if (elements.length > 0) {
                            targetElement = elements[0];
                        }
                    }
                }
                
                // 方式3: 通过选择器查找（如果有保存的元素信息）
                const pageElements = window.pageElements || {};
                const elementData = pageElements[pageKey]?.[elementId];
                if (!targetElement && elementData && elementData.selector) {
                    targetElement = iframeDoc.querySelector(elementData.selector);
                }
                
                if (targetElement) {
                    console.log('找到目标元素，开始高亮:', targetElement);
                    
                    // 如果元素数据不存在，临时创建一个
                    if (!window.pageElements) window.pageElements = {};
                    if (!window.pageElements[pageKey]) window.pageElements[pageKey] = {};
                    if (!window.pageElements[pageKey][elementId]) {
                        window.pageElements[pageKey][elementId] = {
                            id: elementId,
                            name: annotation.name,
                            element: targetElement,
                            rect: targetElement.getBoundingClientRect(),
                            selector: generateElementSelector(targetElement)
                        };
                    }
                    
                    // 高亮元素
                    const highlightSuccess = highlightElement(elementId);
                    
                    if (!highlightSuccess) {
                        console.warn('高亮失败，尝试强制高亮');
                        // 延迟重试高亮
                        setTimeout(() => {
                            highlightElement(elementId);
                        }, 500);
                    }
                    
                    // 滚动到元素
                    targetElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center', 
                        inline: 'center' 
                    });
                } else {
                    console.warn('在当前页面找不到对应元素:', elementId);
                    // 即使找不到元素，也尝试强制高亮
                    setTimeout(() => {
                        const success = highlightElement(elementId);
                        if (!success) {
                            console.error('所有高亮策略都失败了');
                        }
                    }, 1000);
                }
                } catch (error) {
                    console.log('传统高亮元素失败:', error);
                    // 错误情况下也尝试强制高亮
                    setTimeout(() => {
                        highlightElement(elementId);
                    }, 1000);
                }
            }
            
            // 更新元素清单显示
            updateElementList();
            
            console.log('批注选择完成');
        }

        // 选择页面元素
        function selectElement(elementId) {
            selectedElementId = elementId;
            
            // 更新当前批注在列表中的索引
            if (currentPageAnnotationList.length > 0) {
                const index = currentPageAnnotationList.indexOf(elementId);
                if (index !== -1) {
                    currentAnnotationIndex = index;
                }
            }
            
            updateElementList();
            
            // 清除之前的高亮
            clearHighlights();
            
            // 高亮选中的元素
            highlightElement(elementId);
            
            // 更新批注内容显示
            updateAnnotationDisplay(elementId);
        }

        // 高亮元素（全新的鲁棒版本）
        function highlightElement(elementId) {
            console.log('🎯 开始高亮元素:', elementId);
            clearHighlights();
            
            const pageKey = getCurrentPageKey();
            const elementData = pageElements[pageKey]?.[elementId];
            const annotation = currentAnnotations[pageKey]?.[elementId];
            
            console.log('📊 高亮上下文:', {
                pageKey,
                elementData,
                annotation,
                elementId
            });
            
            // 策略1: 虚拟元素高亮（如果是虚拟元素）
            if (elementData && elementData.virtual) {
                return highlightVirtualElement(elementData);
            }
            
            // 策略2: 坐标高亮（基于已保存的位置信息）
            if (elementData && elementData.rect) {
                return highlightByCoordinates(elementData);
            }
            
            // 策略3: 批注信息推断高亮
            if (annotation) {
                return highlightByAnnotationInfo(annotation, elementId);
            }
            
            // 策略4: 智能DOM查找高亮
            return highlightByDOMSearch(elementId);
        }
        
        // 虚拟元素高亮
        function highlightVirtualElement(elementData) {
            console.log('🎭 虚拟元素高亮:', elementData.name);
            
            const iframe = document.getElementById('embeddedFrame');
            const iframeRect = iframe.getBoundingClientRect();
            const scale = parseFloat(iframe.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
            
            // 使用预定义的坐标
            const rect = elementData.rect;
            const left = iframeRect.left + (rect.left * scale);
            const top = iframeRect.top + (rect.top * scale);
            const width = rect.width * scale;
            const height = rect.height * scale;
            
            createHighlightOverlay(left, top, width, height, '虚拟元素: ' + elementData.name);
            return true;
        }
        
        // 坐标高亮
        function highlightByCoordinates(elementData) {
            console.log('📍 坐标高亮:', elementData.name);
            
            const iframe = document.getElementById('embeddedFrame');
            const iframeRect = iframe.getBoundingClientRect();
            const scale = parseFloat(iframe.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
            
            const rect = elementData.rect;
            const left = iframeRect.left + (rect.left * scale);
            const top = iframeRect.top + (rect.top * scale);
            const width = rect.width * scale;
            const height = rect.height * scale;
            
            createHighlightOverlay(left, top, width, height, '坐标定位: ' + elementData.name);
            return true;
        }
        
        // 基于批注信息推断高亮
        function highlightByAnnotationInfo(annotation, elementId) {
            console.log('🔮 推断高亮:', annotation.name);
            
            const iframe = document.getElementById('embeddedFrame');
            const iframeRect = iframe.getBoundingClientRect();
            const scale = parseFloat(iframe.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
            
            // 根据批注名称推断可能的位置
            let estimatedRect = { left: 100, top: 100, width: 200, height: 100 };
            
            const name = annotation.name.toLowerCase();
            if (name.includes('地图') || name.includes('map')) {
                estimatedRect = { left: 400, top: 100, width: 600, height: 400 };
            } else if (name.includes('图表') || name.includes('chart') || name.includes('canvas')) {
                estimatedRect = { left: 100, top: 300, width: 400, height: 300 };
            } else if (name.includes('面板') || name.includes('panel')) {
                estimatedRect = { left: 1100, top: 100, width: 300, height: 200 };
            } else if (name.includes('按钮') || name.includes('button')) {
                estimatedRect = { left: 200, top: 50, width: 100, height: 40 };
            }
            
            const left = iframeRect.left + (estimatedRect.left * scale);
            const top = iframeRect.top + (estimatedRect.top * scale);
            const width = estimatedRect.width * scale;
            const height = estimatedRect.height * scale;
            
            createHighlightOverlay(left, top, width, height, '智能推断: ' + annotation.name, 'warning');
            return true;
        }
        
        // DOM查找高亮 - 精确版
        function highlightByDOMSearch(elementId) {
            console.log('🔍 DOM精确查找高亮:', elementId);
            
            try {
                const iframe = document.getElementById('embeddedFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                const iframeRect = iframe.getBoundingClientRect();
                const scale = parseFloat(iframe.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
                
                const pageKey = getCurrentPageKey();
                const signature = pageElements[pageKey]?.[elementId];
                
                if (!signature) {
                    console.log('❌ 没有找到元素签名');
                    return false;
                }
                
                // 使用新的精确重定位系统
                const targetElement = relocateElementBySignature(signature, iframeDoc);
                
                    if (targetElement) {
                    console.log('✅ 精确定位成功');
                    
                    // 获取元素位置信息
                    const rect = targetElement.getBoundingClientRect();
                    
                    // 计算高亮位置
                    const left = iframeRect.left + (rect.left * scale);
                    const top = iframeRect.top + (rect.top * scale);
                    const width = rect.width * scale;
                    const height = rect.height * scale;
                    
                    // 更新元素签名中的元素引用
                    signature._element = targetElement;
                    
                    // 创建高亮
                    createHighlightOverlay(left, top, width, height, '精确定位: ' + (signature.basic.textContent || signature.basic.tagName), 'success');
                    
                    // 滚动到元素
                    targetElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center', 
                        inline: 'center' 
                    });
                    
                    return true;
                } else {
                    console.log('❌ 精确定位失败，使用备用方案');
                    
                    // 备用方案：使用签名中保存的位置信息
                    if (signature.positioning && signature.positioning.absoluteRect) {
                        const rect = signature.positioning.absoluteRect;
                        const left = iframeRect.left + (rect.left * scale);
                        const top = iframeRect.top + (rect.top * scale);
                        const width = rect.width * scale;
                        const height = rect.height * scale;
                        
                        createHighlightOverlay(left, top, width, height, '历史位置: ' + (signature.basic.textContent || signature.basic.tagName), 'warning');
                        return true;
                    }
                }
                
                // 策略3: 增强的ID和特征匹配
                if (!targetElement) {
                    console.log('策略3: 增强的ID和特征匹配');
                    
                    // 3.1: 直接ID匹配
                    if (elementId.startsWith('id-')) {
                        const actualId = elementId.substring(3);
                        targetElement = iframeDoc.getElementById(actualId);
                        console.log('ID匹配:', actualId, targetElement ? '成功' : '失败');
                    }
                    
                    // 3.2: data-function属性匹配
                    if (!targetElement && elementId.startsWith('data-function-')) {
                        const functionName = elementId.substring(14);
                        targetElement = iframeDoc.querySelector(`[data-function="${functionName}"]`);
                        console.log('data-function匹配:', functionName, targetElement ? '成功' : '失败');
                    }
                    
                    // 3.3: 稳定ID特征匹配
                    if (!targetElement && elementId.startsWith('stable-')) {
                        const features = elementId.substring(7).split('-');
                        const [tagName, className, parentClass] = features;
                        
                        // 组合查询
                        let candidates = [];
                        if (tagName) {
                            candidates = Array.from(iframeDoc.getElementsByTagName(tagName));
                        }
                        
                        if (className && candidates.length > 0) {
                            candidates = candidates.filter(el => el.className.includes(className));
                        }
                        
                        if (parentClass && candidates.length > 0) {
                            candidates = candidates.filter(el => 
                                el.parentElement && el.parentElement.className.includes(parentClass)
                            );
                        }
                        
                        if (candidates.length > 0) {
                            targetElement = candidates[0];
                            console.log('稳定特征匹配成功:', features);
                        }
                    }
                    
                    // 3.4: 类名模糊匹配
                    if (!targetElement) {
                        const classMatches = elementId.match(/([a-zA-Z-]+)/g);
                        if (classMatches) {
                            for (const className of classMatches) {
                                if (className.length > 3) { // 忽略太短的匹配
                                const elements = iframeDoc.getElementsByClassName(className);
                                if (elements.length > 0) {
                                    targetElement = elements[0];
                                    console.log('类名匹配成功:', className);
                                    break;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 策略4: 模糊搜索（根据批注名称）
                if (!targetElement) {
                    console.log('策略4: 模糊搜索');
                    const annotation = currentAnnotations[pageKey]?.[elementId];
                    if (annotation && annotation.name) {
                        // 查找包含相似文本的元素
                        const allElements = iframeDoc.querySelectorAll('*');
                        for (const el of allElements) {
                            const text = el.textContent?.trim();
                            if (text && text.includes(annotation.name.replace(/[📝🌾🥬⚠️📈📊🌤️]/g, '').trim())) {
                                targetElement = el;
                                console.log('模糊搜索成功:', text);
                                break;
                            }
                        }
                    }
                }
                
                if (targetElement) {
                    console.log('找到目标元素:', targetElement);
                    
                    // 获取元素的实际位置
                    const rect = targetElement.getBoundingClientRect();
                    console.log('元素位置信息:', rect);
                    
                    // 确保元素在iframe的坐标系中
                    const iframeWindow = iframe.contentWindow;
                    const iframeScrollX = iframeWindow.pageXOffset || iframeDoc.documentElement.scrollLeft;
                    const iframeScrollY = iframeWindow.pageYOffset || iframeDoc.documentElement.scrollTop;
                    
                    console.log('iframe滚动位置:', { scrollX: iframeScrollX, scrollY: iframeScrollY });
                    
                    // 计算高亮层的位置（考虑iframe的位置、缩放和滚动）
                    const left = iframeRect.left + (rect.left * scale);
                    const top = iframeRect.top + (rect.top * scale);
                    const width = rect.width * scale;
                    const height = rect.height * scale;
                    
                    console.log('计算的高亮位置:', { left, top, width, height });
                    
                    // 创建高亮覆盖层
                    const highlight = document.createElement('div');
                    highlight.className = 'highlight-overlay';
                    highlight.id = 'current-highlight';
                    
                    // 设置样式
                    highlight.style.position = 'fixed';
                    highlight.style.left = left + 'px';
                    highlight.style.top = top + 'px';
                    highlight.style.width = width + 'px';
                    highlight.style.height = height + 'px';
                    highlight.style.zIndex = '1000';
                    highlight.style.pointerEvents = 'none';
                    
                    // 添加明显的视觉效果用于调试
                    highlight.style.border = '3px solid #ff0000';
                    highlight.style.background = 'rgba(255, 0, 0, 0.2)';
                    highlight.style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.8)';
                    
                    document.body.appendChild(highlight);
                    
                    console.log('高亮层已添加到DOM');
                    
                    // 更新或创建元素数据
                    if (!window.pageElements) window.pageElements = {};
                    if (!window.pageElements[pageKey]) window.pageElements[pageKey] = {};
                    window.pageElements[pageKey][elementId] = {
                        id: elementId,
                        name: currentAnnotations[pageKey]?.[elementId]?.name || 'Unknown',
                        element: targetElement,
                        rect: rect,
                        selector: generateElementSelector(targetElement)
                    };
                    
                    // 滚动到元素
                    targetElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center', 
                        inline: 'center' 
                    });
                    
                    // 3秒后恢复正常样式
                    setTimeout(() => {
                        if (highlight.parentNode) {
                            highlight.style.border = '3px solid #ffc107';
                            highlight.style.background = 'rgba(255, 193, 7, 0.3)';
                            highlight.style.boxShadow = '0 0 20px rgba(255, 193, 7, 0.5)';
                        }
                    }, 3000);
                    
                    console.log('高亮完成');
                    return true;
                    
                } else {
                    console.error('无法找到目标元素，所有策略都失败了');
                    
                    // 显示错误提示
                    const errorOverlay = document.createElement('div');
                    errorOverlay.style.position = 'fixed';
                    errorOverlay.style.top = '50%';
                    errorOverlay.style.left = '50%';
                    errorOverlay.style.transform = 'translate(-50%, -50%)';
                    errorOverlay.style.background = 'rgba(220, 53, 69, 0.9)';
                    errorOverlay.style.color = 'white';
                    errorOverlay.style.padding = '20px';
                    errorOverlay.style.borderRadius = '8px';
                    errorOverlay.style.zIndex = '2000';
                    errorOverlay.style.textAlign = 'center';
                    errorOverlay.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 10px;">⚠️</div>
                        <div>无法找到页面元素</div>
                        <div style="margin-top: 8px; font-size: 12px;">元素ID: ${elementId}</div>
                        <div style="margin-top: 8px; font-size: 12px;">可能需要重新抓取页面元素</div>
                    `;
                    
                    document.body.appendChild(errorOverlay);
                    setTimeout(() => {
                        if (errorOverlay.parentNode) {
                            errorOverlay.remove();
                        }
                    }, 3000);
                    
                    return false;
                }
                
            } catch (error) {
                console.error('高亮过程发生错误:', error);
                alert('高亮失败: ' + error.message);
                return false;
            }
        }

        // 创建高亮覆盖层
        function createHighlightOverlay(left, top, width, height, label = '', type = 'success') {
            console.log('🎨 创建高亮覆盖层:', { left, top, width, height, label, type });
            
            // 创建高亮框
            const highlight = document.createElement('div');
            highlight.className = 'highlight-overlay';
            highlight.id = 'current-highlight';
            
            // 根据类型设置样式
            let borderColor, backgroundColor, labelColor;
            switch (type) {
                case 'warning':
                    borderColor = '#ff9800';
                    backgroundColor = 'rgba(255, 152, 0, 0.2)';
                    labelColor = '#ff9800';
                    break;
                case 'error':
                    borderColor = '#f44336';
                    backgroundColor = 'rgba(244, 67, 54, 0.2)';
                    labelColor = '#f44336';
                    break;
                case 'info':
                    borderColor = '#2196F3';
                    backgroundColor = 'rgba(33, 150, 243, 0.2)';
                    labelColor = '#2196F3';
                    break;
                default: // success
                    borderColor = '#4CAF50';
                    backgroundColor = 'rgba(76, 175, 80, 0.2)';
                    labelColor = '#4CAF50';
            }
            
            // 设置基本样式
            highlight.style.position = 'fixed';
            highlight.style.left = left + 'px';
            highlight.style.top = top + 'px';
            highlight.style.width = width + 'px';
            highlight.style.height = height + 'px';
            highlight.style.border = `3px solid ${borderColor}`;
            highlight.style.background = backgroundColor;
            highlight.style.zIndex = '1000';
            highlight.style.pointerEvents = 'none';
            highlight.style.borderRadius = '4px';
            highlight.style.boxShadow = `0 0 20px ${backgroundColor}`;
            
            // 添加动画效果
            highlight.style.animation = 'highlight-pulse 2s infinite';
            
            // 添加标签
            if (label) {
                const labelElement = document.createElement('div');
                labelElement.style.position = 'absolute';
                labelElement.style.top = '-25px';
                labelElement.style.left = '0';
                labelElement.style.background = borderColor;
                labelElement.style.color = 'white';
                labelElement.style.padding = '4px 8px';
                labelElement.style.borderRadius = '4px';
                labelElement.style.fontSize = '12px';
                labelElement.style.fontWeight = 'bold';
                labelElement.style.whiteSpace = 'nowrap';
                labelElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                labelElement.textContent = label;
                highlight.appendChild(labelElement);
            }
            
            document.body.appendChild(highlight);
            
            // 3秒后淡化效果
            setTimeout(() => {
                if (highlight.parentNode) {
                    highlight.style.opacity = '0.7';
                    highlight.style.animation = 'none';
                }
            }, 3000);
            
            return highlight;
        }

        // 清除高亮
        function clearHighlights() {
            const highlights = document.querySelectorAll('.highlight-overlay');
            highlights.forEach(highlight => {
                // 添加淡出动画
                highlight.style.transition = 'opacity 0.3s ease';
                highlight.style.opacity = '0';
                setTimeout(() => {
                    if (highlight.parentNode) {
                        highlight.remove();
                    }
                }, 300);
            });
        }

        // 更新批注显示
        function updateAnnotationDisplay(elementId) {
            console.log('updateAnnotationDisplay 被调用:', elementId);
            
            const pageKey = getCurrentPageKey();
            const pageAnnotations = currentAnnotations[pageKey] || {};
            const elementAnnotation = pageAnnotations[elementId];
            const element = pageElements[pageKey]?.[elementId];
            
            console.log('批注显示参数:', {
                pageKey,
                elementId,
                hasAnnotation: !!elementAnnotation,
                hasElement: !!element,
                annotation: elementAnnotation
            });
            
            const annotationContent = document.getElementById('annotationContent');
            
            if (!annotationContent) {
                console.error('找不到annotationContent元素');
                return;
            }
            
            if (elementAnnotation) {
                // 显示现有批注
                console.log('显示现有批注:', elementAnnotation);
                annotationContent.innerHTML = `
                    <div class="annotation-item">
                        <div class="annotation-title">📍 ${elementAnnotation.name}</div>
                        <div class="annotation-content" style="margin-top: 8px; padding: 8px; background: #333; border-radius: 4px; line-height: 1.4;">
                            ${convertMarkdownToHTML(elementAnnotation.content)}
                        </div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #404040;">
                            <small style="color: #999;">创建时间: ${elementAnnotation.timestamp}</small>
                        </div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #404040;">
                            <small style="color: #999;">页面: ${pageKey}</small><br>
                            <small style="color: #999;">元素ID: ${elementId}</small>
                        </div>
                        ${isAnnotationMode ? `
                        <div style="margin-top: 8px;">
                            <button onclick="editAnnotation('${elementId}')" class="nav-button" style="margin: 2px;">编辑</button>
                            <button onclick="deleteAnnotation('${elementId}')" class="nav-button" style="margin: 2px; background: #dc3545;">删除</button>
                        </div>
                        ` : `
                        <div style="margin-top: 8px;">
                            <button onclick="toggleAnnotationMode()" class="nav-button" style="margin: 2px; background: #667eea;">进入批注模式编辑</button>
                        </div>
                        `}
                    </div>
                `;
                
                // 添加成功提示
                setTimeout(() => {
                    const title = annotationContent.querySelector('.annotation-title');
                    if (title) {
                        title.style.background = '#4CAF50';
                        title.style.color = 'white';
                        title.style.padding = '4px 8px';
                        title.style.borderRadius = '4px';
                        title.style.display = 'inline-block';
                        title.style.marginBottom = '8px';
                    }
                }, 100);
                
            } else if (isAnnotationMode && element) {
                // 批注模式下显示创建表单
                annotationContent.innerHTML = `
                    <div class="annotation-item">
                        <div class="annotation-title">📝 创建新批注</div>
                        <div style="margin-top: 8px;">
                            <input type="text" id="annotationTitle" placeholder="批注标题" value="${getElementDisplayName(element)}"
                                   style="width: 100%; padding: 6px; background: #404040; border: 1px solid #606060; 
                                          color: #fff; border-radius: 3px; margin-bottom: 8px;">
                            <textarea id="annotationContentInput" placeholder="批注内容" rows="4"
                                      style="width: 100%; padding: 6px; background: #404040; border: 1px solid #606060; 
                                             color: #fff; border-radius: 3px; resize: vertical; margin-bottom: 8px;"></textarea>
                            <button onclick="saveElementAnnotation('${elementId}')" class="nav-button">保存批注</button>
                            <button onclick="cancelAnnotation()" class="nav-button" style="margin-left: 8px;">取消</button>
                        </div>
                    </div>
                `;
            } else {
                // 普通模式下显示提示
                annotationContent.innerHTML = `
                    <div class="annotation-item">
                        <div class="annotation-title">💡 提示</div>
                        <div class="annotation-content">
                            该元素暂无批注。开启批注模式可以添加批注内容。
                        </div>
                    </div>
                `;
            }
        }

        // 验证DOM元素是否有效
        function isValidDOMElement(element) {
            return element && 
                   element.nodeType === Node.ELEMENT_NODE && 
                   element.tagName && 
                   typeof element.tagName === 'string';
        }

        // 生成智能元素选择器
        function generateSmartSelector(element) {
            // 验证输入元素
            if (!isValidDOMElement(element)) {
                console.error('❌ generateSmartSelector: 无效的元素参数', element);
                return null;
            }
            
            const path = [];
            let current = element;
            
            while (current && current !== document.body && current.tagName) {
                let selector = current.tagName.toLowerCase();
                
                // 添加ID（如果有且唯一）
                if (current.id) {
                    selector += '#' + current.id;
                    path.unshift(selector);
                    break; // ID是唯一的，可以直接使用
                }
                
                // 添加类名
                if (current.className && typeof current.className === 'string') {
                    const classes = current.className.trim().split(/\s+/);
                    if (classes.length > 0 && classes[0] !== '') {
                        selector += '.' + classes.join('.');
                    }
                }
                
                // 如果元素有特殊属性，添加属性选择器
                if (current.hasAttribute('data-function')) {
                    selector += `[data-function="${current.getAttribute('data-function')}"]`;
                }
                if (current.hasAttribute('data-chart-type')) {
                    selector += `[data-chart-type="${current.getAttribute('data-chart-type')}"]`;
                }
                
                // 如果有文本内容，作为额外的识别信息
                const textContent = current.textContent?.trim();
                if (textContent && textContent.length < 50 && textContent.length > 0) {
                    // 转义特殊字符
                    const escapedText = textContent.replace(/['"\\]/g, '\\$&');
                    if (!textContent.includes('\n') && !textContent.includes('\t')) {
                        selector += `[data-text-content*="${escapedText.substring(0, 20)}"]`;
                    }
                }
                
                // 计算同级元素中的位置
                const siblings = Array.from(current.parentNode?.children || []);
                const sameTagSiblings = siblings.filter(sibling => 
                    sibling.tagName === current.tagName && 
                    sibling.className === current.className
                );
                
                if (sameTagSiblings.length > 1) {
                    const index = sameTagSiblings.indexOf(current);
                    selector += `:nth-of-type(${index + 1})`;
                }
                
                path.unshift(selector);
                current = current.parentNode;
            }
            
            return path.join(' > ');
        }

        // 生成元素指纹（用于内容识别）
        function generateElementFingerprint(element) {
            // 验证输入元素
            if (!isValidDOMElement(element)) {
                console.error('❌ generateElementFingerprint: 无效的元素参数', element);
                return null;
            }
            
            const fingerprint = {
                tagName: element.tagName,
                className: element.className,
                textContent: element.textContent?.trim().substring(0, 100) || '',
                attributes: {},
                position: {
                    offsetLeft: element.offsetLeft,
                    offsetTop: element.offsetTop,
                    offsetWidth: element.offsetWidth,
                    offsetHeight: element.offsetHeight
                }
            };
            
            // 收集重要属性
            const importantAttrs = ['id', 'data-function', 'data-chart-type', 'data-panel', 'role', 'aria-label'];
            importantAttrs.forEach(attr => {
                if (element.hasAttribute(attr)) {
                    fingerprint.attributes[attr] = element.getAttribute(attr);
                }
            });
            
            // 如果是图表容器，尝试获取图表类型
            if (element.querySelector('canvas') || element.querySelector('.echarts-instance')) {
                fingerprint.chartType = 'echarts';
            }
            
            return fingerprint;
        }

        // 改进的元素匹配函数
        function findElementByFingerprint(fingerprint, container = document) {
            const candidates = container.querySelectorAll(fingerprint.tagName);
            let bestMatch = null;
            let bestScore = 0;
            
            candidates.forEach(element => {
                let score = 0;
                
                // 类名匹配
                if (element.className === fingerprint.className) score += 30;
                
                // 文本内容匹配
                const elementText = element.textContent?.trim() || '';
                if (elementText === fingerprint.textContent) score += 50;
                else if (elementText.includes(fingerprint.textContent.substring(0, 20))) score += 25;
                
                // 属性匹配
                Object.entries(fingerprint.attributes).forEach(([attr, value]) => {
                    if (element.hasAttribute(attr) && element.getAttribute(attr) === value) {
                        score += 20;
                    }
                });
                
                // 位置匹配（相对位置）
                const posDiff = Math.abs(element.offsetLeft - fingerprint.position.offsetLeft) + 
                               Math.abs(element.offsetTop - fingerprint.position.offsetTop);
                if (posDiff < 50) score += 15;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = element;
                }
            });
            
            return bestScore > 60 ? bestMatch : null; // 设置最低匹配阈值
        }

        // 保存元素批注
        async function saveElementAnnotation(elementId) {
            const titleInput = document.getElementById('annotationTitle');
            const contentInput = document.getElementById('annotationContentInput');
            
            if (!titleInput || !contentInput) {
                alert('无法找到批注表单元素');
                return;
            }
            
            const title = titleInput.value;
            const content = contentInput.value;
            
            if (!title.trim() || !content.trim()) {
                alert('请填写批注标题和内容');
                return;
            }
            
            // 获取当前选中的元素信息
            const pageKey = getCurrentPageKey();
            const elementData = pageElements[pageKey]?.[elementId];
            
            if (!elementData) {
                alert('无法找到元素数据，请重新选择元素');
                return;
            }
            
            // 使用示例数据格式重新定位元素
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) {
                alert('无法访问iframe内容');
                return;
            }
            
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            
            // 使用多策略智能定位元素
            let targetElement = null;
            let matchStrategy = '';
            
            console.log('🔍 开始重新定位元素:', elementId);
            console.log('📋 元素数据:', elementData);
            
            // 策略1: 使用原生ID
            if (elementData.basic?.id && elementData.basic.id !== 'null') {
                targetElement = iframeDoc.getElementById(elementData.basic.id);
                if (targetElement) {
                    matchStrategy = 'ID匹配';
                    console.log('✅ 通过ID找到元素:', elementData.basic.id);
                }
            }
            
            // 策略2: 使用多种选择器
            if (!targetElement && elementData.hierarchy?.selectors) {
                const selectors = elementData.hierarchy.selectors;
                
                // 尝试primary选择器
                if (selectors.primary) {
                    try {
                        targetElement = iframeDoc.querySelector(selectors.primary);
                        if (targetElement) {
                            matchStrategy = 'Primary选择器';
                            console.log('✅ 通过Primary选择器找到元素:', selectors.primary);
                        }
                    } catch (e) {
                        console.warn('Primary选择器失败:', e);
                    }
                }
                
                // 尝试unique选择器
                if (!targetElement && selectors.unique) {
                    try {
                        targetElement = iframeDoc.querySelector(selectors.unique);
                        if (targetElement) {
                            matchStrategy = 'Unique选择器';
                            console.log('✅ 通过Unique选择器找到元素:', selectors.unique);
                        }
                    } catch (e) {
                        console.warn('Unique选择器失败:', e);
                    }
                }
                
                // 尝试CSS路径
                if (!targetElement && selectors.cssPath) {
                    try {
                        targetElement = iframeDoc.querySelector(selectors.cssPath);
                        if (targetElement) {
                            matchStrategy = 'CSS路径';
                            console.log('✅ 通过CSS路径找到元素:', selectors.cssPath);
                        }
                    } catch (e) {
                        console.warn('CSS路径查找失败:', e);
                    }
                }
            }
            
            // 策略3: 使用标签名+位置索引精确匹配
            if (!targetElement && elementData.basic?.tagName && elementData.positioning) {
                const candidates = iframeDoc.querySelectorAll(elementData.basic.tagName);
                const targetIndex = elementData.positioning.siblingIndex?.index;
                
                if (typeof targetIndex === 'number' && candidates[targetIndex]) {
                    // 验证这个元素是否真的匹配
                    const candidate = candidates[targetIndex];
                    
                    // 简化版本的元素匹配验证
                    let matchScore = 0;
                    
                    // 标签名匹配
                    if (candidate.tagName.toLowerCase() === elementData.basic.tagName) {
                        matchScore += 30;
                    }
                    
                    // 类名匹配
                    if (elementData.basic.className && candidate.className.includes(elementData.basic.className.split(' ')[0])) {
                        matchScore += 20;
                    }
                    
                    // 文本内容匹配
                    if (elementData.basic.textContent && candidate.textContent?.includes(elementData.basic.textContent)) {
                        matchScore += 30;
                    }
                    
                    // 位置匹配
                    const siblings = Array.from(candidate.parentElement?.children || []);
                    const currentIndex = siblings.indexOf(candidate);
                    if (currentIndex === targetIndex) {
                        matchScore += 20;
                    }
                    
                    if (matchScore > 50) { // 设置匹配阈值
                        targetElement = candidate;
                        matchStrategy = `位置索引匹配(${targetIndex}) - 得分:${matchScore}`;
                        console.log('✅ 通过位置索引找到元素，匹配得分:', matchScore);
                    }
                }
            }
            
            // 策略4: Canvas和特殊元素的位置匹配
            if (!targetElement && elementData.basic?.tagName === 'canvas') {
                const canvasElements = iframeDoc.querySelectorAll('canvas');
                if (canvasElements.length > 0) {
                    // 如果只有一个canvas，直接使用
                    if (canvasElements.length === 1) {
                        targetElement = canvasElements[0];
                        matchStrategy = '唯一Canvas元素';
                        console.log('✅ 找到唯一Canvas元素');
                    } else {
                        // 多个canvas时，使用位置信息匹配
                        const targetRect = elementData.positioning?.absoluteRect;
                        if (targetRect) {
                            let bestMatch = null;
                            let minDistance = Infinity;
                            
                            canvasElements.forEach(canvas => {
                                const rect = canvas.getBoundingClientRect();
                                const distance = Math.abs(rect.left - targetRect.left) + 
                                               Math.abs(rect.top - targetRect.top);
                                
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestMatch = canvas;
                                }
                            });
                            
                            if (bestMatch && minDistance < 100) { // 位置差异小于100px
                                targetElement = bestMatch;
                                matchStrategy = `Canvas位置匹配 - 距离:${minDistance}px`;
                                console.log('✅ 通过位置匹配找到Canvas元素');
                            }
                        }
                    }
                }
            }
            
            // 策略5: 类名+文本内容匹配（作为备用）
            if (!targetElement && elementData.basic?.className && elementData.basic?.textContent) {
                const className = elementData.basic.className.split(' ')[0];
                if (className && className !== 'null') {
                    const candidates = iframeDoc.querySelectorAll(`.${className}`);
                    if (candidates.length > 0) {
                        targetElement = Array.from(candidates).find(el => 
                            el.textContent?.trim().includes(elementData.basic.textContent)
                        );
                        if (targetElement) {
                            matchStrategy = '类名+文本内容匹配';
                            console.log('✅ 通过类名+文本内容找到元素');
                        }
                    }
                }
            }
            
            if (!targetElement) {
                // 提供详细的调试信息
                const debugInfo = {
                    elementId: elementId,
                    hasBasicId: !!elementData.basic?.id,
                    hasSelectors: !!elementData.hierarchy?.selectors,
                    tagName: elementData.basic?.tagName,
                    className: elementData.basic?.className,
                    hasPositioning: !!elementData.positioning,
                    availableStrategies: []
                };
                
                if (elementData.basic?.id && elementData.basic.id !== 'null') {
                    debugInfo.availableStrategies.push('ID查找');
                }
                if (elementData.hierarchy?.selectors) {
                    debugInfo.availableStrategies.push('选择器查找');
                }
                if (elementData.positioning) {
                    debugInfo.availableStrategies.push('位置匹配');
                }
                
                console.error('❌ 所有定位策略都失败了:', debugInfo);
                
                alert(`无法重新定位元素: ${elementId}\n\n调试信息:\n- 元素类型: ${elementData.basic?.tagName || '未知'}\n- 是否有ID: ${debugInfo.hasBasicId}\n- 是否有选择器: ${debugInfo.hasSelectors}\n- 是否有位置信息: ${debugInfo.hasPositioning}\n\n请尝试：\n1. 刷新页面后重新选择元素\n2. 确保页面内容已完全加载\n3. 选择具有明确ID或类名的元素`);
                return;
            }
            
            console.log(`🎯 成功重新定位元素! 策略: ${matchStrategy}`);
            console.log('目标元素:', targetElement);
            
            // 最终验证目标元素的有效性
            if (!isValidDOMElement(targetElement)) {
                console.error('❌ 重新定位的元素无效', targetElement);
                alert('定位到的元素无效，无法保存批注。请尝试选择其他元素。');
                return;
            }
            
            // 生成智能选择器和元素指纹（参考示例数据格式）
            const smartSelector = generateSmartSelector(targetElement);
            if (!smartSelector) {
                console.error('❌ 无法生成智能选择器，跳过保存');
                alert('元素选择器生成失败，无法保存批注。请尝试选择其他元素。');
                return;
            }
            const elementFingerprint = generateElementFingerprint(targetElement);
            if (!elementFingerprint) {
                console.error('❌ 无法生成元素指纹，跳过保存');
                alert('元素指纹生成失败，无法保存批注。请尝试选择其他元素。');
                return;
            }
            
            // 获取元素的基本信息
            const elementText = targetElement.textContent?.trim() || title;
            const elementClass = targetElement.className || '';
            
            if (!currentAnnotations[pageKey]) {
                currentAnnotations[pageKey] = {};
            }
            
            // 使用示例数据的格式结构
            currentAnnotations[pageKey][elementId] = {
                name: title,
                content: content,
                timestamp: new Date().toLocaleString('zh-CN'),
                elementId: elementId,
                targetInfo: {
                    smartSelector: smartSelector,
                    elementFingerprint: {
                        tagName: targetElement.tagName.toUpperCase(),
                        className: elementClass,
                        textContent: elementText,
                        attributes: elementFingerprint.attributes || {},
                        position: elementFingerprint.position || {
                            offsetLeft: targetElement.offsetLeft || 0,
                            offsetTop: targetElement.offsetTop || 0,
                            offsetWidth: targetElement.offsetWidth || 0,
                            offsetHeight: targetElement.offsetHeight || 0
                        },
                        chartType: elementFingerprint.chartType || null
                    },
                    fallbackSelector: targetElement.tagName.toLowerCase() + 
                        (targetElement.className ? '.' + targetElement.className.split(' ').join('.') : ''),
                    textContent: elementText,
                    pageUrl: iframe.src,
                    timestamp: new Date().toISOString()
                }
            };
            
            console.log('💾 保存批注数据:', currentAnnotations[pageKey][elementId]);
            
            // 优先使用增量更新（开发模式）
            if (CURRENT_ENV.enableRealTimeSync) {
                console.log('🚀 使用增量更新模式');
                
                // 增量更新到服务器
                const updateResult = await apiClient.updateAnnotation(
                    pageKey, 
                    elementId, 
                    currentAnnotations[pageKey][elementId], 
                    'update'
                );
                
                if (updateResult) {
                    console.log('✅ 增量更新成功');
                    
                    // 广播同步事件
                    await apiClient.syncAnnotation(currentAnnotations[pageKey][elementId], 'create');
                } else {
                    console.warn('⚠️ 增量更新失败，回退到全量保存');
                    await saveAnnotations();
                }
            } else {
                // 线上模式或本地模式：全量保存
                await saveAnnotations();
            }
            updateElementList();
            updateAnnotationDisplay(elementId);
        }

        // 编辑批注
        function editAnnotation(elementId) {
            // 权限检查
            if (!checkPermission('edit')) {
                showPermissionDenied('edit');
                return;
            }
            
            const pageKey = getCurrentPageKey();
            const annotation = currentAnnotations[pageKey][elementId];
            
            const annotationContent = document.getElementById('annotationContent');
            annotationContent.innerHTML = `
                <div class="annotation-item">
                    <div class="annotation-title">✏️ 编辑批注</div>
                    <div style="margin-top: 8px;">
                        <input type="text" id="annotationTitle" value="${annotation.name}" placeholder="批注标题" 
                               style="width: 100%; padding: 6px; background: #404040; border: 1px solid #606060; 
                                      color: #fff; border-radius: 3px; margin-bottom: 8px;">
                        <textarea id="annotationContentInput" placeholder="批注内容" rows="4"
                                  style="width: 100%; padding: 6px; background: #404040; border: 1px solid #606060; 
                                         color: #fff; border-radius: 3px; resize: vertical; margin-bottom: 8px;">${annotation.content}</textarea>
                        <button onclick="saveElementAnnotation('${elementId}')" class="nav-button">保存修改</button>
                        <button onclick="updateAnnotationDisplay('${elementId}')" class="nav-button" style="margin-left: 8px;">取消</button>
                    </div>
                </div>
            `;
        }

        // 删除批注
        async function deleteAnnotation(elementId) {
            // 权限检查
            if (!checkPermission('edit')) {
                showPermissionDenied('edit');
                return;
            }
            
            if (confirm('确定要删除这个批注吗？')) {
                const pageKey = getCurrentPageKey();
                const deletedAnnotation = currentAnnotations[pageKey][elementId];
                
                // 从本地数据中删除
                delete currentAnnotations[pageKey][elementId];
                
                // 优先使用增量删除（开发模式）
                if (CURRENT_ENV.enableRealTimeSync && deletedAnnotation) {
                    console.log('🚀 使用增量删除模式');
                    
                    // 增量删除
                    const deleteResult = await apiClient.updateAnnotation(
                        pageKey, 
                        elementId, 
                        deletedAnnotation, 
                        'delete'
                    );
                    
                    if (deleteResult) {
                        console.log('✅ 增量删除成功');
                        
                        // 广播同步事件
                        await apiClient.syncAnnotation(deletedAnnotation, 'delete');
                    } else {
                        console.warn('⚠️ 增量删除失败，回退到全量保存');
                        await saveAnnotations();
                    }
                } else {
                    // 线上模式或本地模式：全量保存
                    await saveAnnotations();
                }
                
                updateElementList();
                updateAnnotationDisplay(elementId);
            }
        }

        // 取消批注
        function cancelAnnotation() {
            selectedElementId = null;
            updateElementList();
            clearHighlights();
            
            // 恢复默认批注显示
            const currentPage = pages[currentPageIndex];
            const config = pageConfigs[currentPage];
            const annotationContent = document.getElementById('annotationContent');
            annotationContent.innerHTML = config.annotations.map(annotation => `
                <div class="annotation-item">
                    <div class="annotation-title">${annotation.title}</div>
                    <div class="annotation-content">${convertMarkdownToHTML(annotation.content)}</div>
                </div>
            `).join('');
        }

        // 确保弹窗可见性
        async function ensureModalVisibility(annotation) {
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) {
                console.warn('无法访问iframe内容');
                return false;
            }
            
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (!iframeDoc) {
                console.warn('无法访问iframe文档');
                return false;
            }
            
            console.log('🔍 检查是否需要显示弹窗:', annotation);
            
            // 先尝试找到目标元素
            let targetElement = await findTargetElement(annotation, iframeDoc);
            
            if (!targetElement) {
                console.log('❌ 无法找到目标元素，尝试显示相关弹窗');
                await attemptToShowRelatedModals(annotation, iframeDoc);
                
                // 重新尝试查找元素
                await new Promise(resolve => setTimeout(resolve, 800));
                targetElement = await findTargetElement(annotation, iframeDoc);
            }
            
            if (targetElement) {
                // 检查元素是否在弹窗中，如果是则确保弹窗可见
                const modalContainer = findParentModal(targetElement);
                if (modalContainer) {
                    console.log('🎯 找到父级弹窗容器:', modalContainer);
                    await showModal(modalContainer, iframeDoc);
                } else {
                    // 检查元素是否当前可见
                    const isVisible = isElementVisible(targetElement);
                    if (!isVisible) {
                        console.log('🔍 元素不可见，尝试显示相关弹窗');
                        await attemptToShowRelatedModals(annotation, iframeDoc);
                    }
                }
            }
            
            return true;
        }
        
        // 查找目标元素
        async function findTargetElement(annotation, iframeDoc) {
            let targetElement = null;
            
            // 策略1: 使用智能选择器
            if (annotation.targetInfo?.smartSelector) {
                try {
                    targetElement = iframeDoc.querySelector(annotation.targetInfo.smartSelector);
                    if (targetElement) {
                        console.log('✅ 通过智能选择器找到元素');
                        return targetElement;
                    }
                } catch (e) {
                    console.warn('智能选择器查找失败:', e);
                }
            }
            
            // 策略2: 使用元素指纹匹配
            if (!targetElement && annotation.targetInfo?.elementFingerprint) {
                targetElement = findElementByFingerprint(annotation.targetInfo.elementFingerprint, iframeDoc);
                if (targetElement) {
                    console.log('✅ 通过元素指纹找到元素');
                    return targetElement;
                }
            }
            
            // 策略3: 使用备用选择器
            if (!targetElement && annotation.targetInfo?.fallbackSelector) {
                try {
                    const candidates = iframeDoc.querySelectorAll(annotation.targetInfo.fallbackSelector);
                    if (candidates.length === 1) {
                        targetElement = candidates[0];
                    } else if (candidates.length > 1 && annotation.targetInfo.textContent) {
                        targetElement = Array.from(candidates).find(el => 
                            el.textContent?.trim().includes(annotation.targetInfo.textContent)
                        );
                    }
                    if (targetElement) {
                        console.log('✅ 通过备用选择器找到元素');
                        return targetElement;
                    }
                } catch (e) {
                    console.warn('备用选择器查找失败:', e);
                }
            }
            
            return null;
        }
        
        // 查找父级弹窗容器
        function findParentModal(element) {
            if (!element) return null;
            
            let current = element;
            let searchDepth = 0;
            const maxDepth = 15; // 增加搜索深度
            
            // 弹窗相关的类名和ID关键词
            const modalKeywords = [
                'modal', 'dialog', 'popup', 'overlay', 'lightbox', 'popover',
                'tooltip', 'dropdown', 'menu', 'panel', 'drawer', 'sidebar',
                'detail', 'info', 'settings', 'config', 'form', 'edit',
                'plot-popup', 'crop-detail', 'device-info', 'weather-detail'
            ];
            
            while (current && current !== document.body && searchDepth < maxDepth) {
                const className = (current.className || '').toLowerCase();
                const id = (current.id || '').toLowerCase();
                const tagName = current.tagName.toLowerCase();
                
                // 检查是否是弹窗容器
                const isModal = modalKeywords.some(keyword => 
                    className.includes(keyword) || id.includes(keyword)
                );
                
                // 特殊检查：常见的弹窗结构
                const hasModalStructure = (
                    className.includes('show') ||
                    className.includes('active') ||
                    className.includes('visible') ||
                    current.hasAttribute('role') && current.getAttribute('role') === 'dialog' ||
                    current.style.position === 'absolute' ||
                    current.style.position === 'fixed'
                ) && (
                    current.style.zIndex > 1000 ||
                    className.includes('z-') ||
                    tagName === 'dialog'
                );
                
                if (isModal || hasModalStructure) {
                    console.log('🎯 找到弹窗容器:', {
                        element: current.tagName,
                        className: current.className,
                        id: current.id,
                        depth: searchDepth,
                        reason: isModal ? '关键词匹配' : '结构匹配'
                    });
                    return current;
                }
                
                current = current.parentElement;
                searchDepth++;
            }
            
            return null;
        }
        
        // 显示弹窗
        async function showModal(modalElement, iframeDoc) {
            if (!modalElement) return false;
            
            console.log('👁️ 显示弹窗:', {
                element: modalElement.tagName,
                className: modalElement.className,
                id: modalElement.id
            });
            
            const style = iframeDoc.defaultView.getComputedStyle(modalElement);
            
            // 检查当前可见性
            const isCurrentlyVisible = (
                style.display !== 'none' &&
                style.visibility !== 'hidden' &&
                parseFloat(style.opacity) > 0.1
            );
            
            if (!isCurrentlyVisible) {
                console.log('🔧 弹窗当前不可见，正在显示...');
                
                // 设置基本显示样式
                modalElement.style.display = 'block';
                modalElement.style.visibility = 'visible';
                modalElement.style.opacity = '1';
                
                // 确保合适的定位和层级
                if (!modalElement.style.position || modalElement.style.position === 'static') {
                    modalElement.style.position = 'absolute';
                }
                
                if (!modalElement.style.zIndex || parseInt(modalElement.style.zIndex) < 1000) {
                    modalElement.style.zIndex = '10000';
                }
                
                // 移除隐藏类，添加显示类
                const hiddenClasses = ['hidden', 'hide', 'd-none', 'opacity-0', 'invisible'];
                const showClasses = ['show', 'visible', 'active', 'opacity-100', 'block'];
                
                hiddenClasses.forEach(cls => modalElement.classList.remove(cls));
                showClasses.forEach(cls => modalElement.classList.add(cls));
                
                // 触发可能存在的显示事件
                try {
                    const showEvent = new iframeDoc.defaultView.CustomEvent('modal:show', {
                        bubbles: true,
                        detail: { element: modalElement }
                    });
                    modalElement.dispatchEvent(showEvent);
                } catch (e) {
                    console.warn('触发显示事件失败:', e);
                }
                
                console.log('✅ 弹窗已显示');
                return true;
            } else {
                console.log('✅ 弹窗已经可见');
                return true;
            }
        }
        
        // 检查元素是否可见
        function isElementVisible(element) {
            if (!element) return false;
            
            try {
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                
                return (
                    rect.width > 0 && 
                    rect.height > 0 &&
                    style.display !== 'none' &&
                    style.visibility !== 'hidden' &&
                    parseFloat(style.opacity) > 0.1
                );
            } catch (e) {
                console.warn('检查元素可见性失败:', e);
                return false;
            }
        }
        
        // 尝试显示相关弹窗
        async function attemptToShowRelatedModals(annotation, iframeDoc) {
            console.log('🚀 尝试显示相关弹窗...');
            
            // 优先策略：直接根据选择器查找弹窗容器
            const priorityResult = await showModalBySelector(annotation, iframeDoc);
            if (priorityResult) {
                console.log('✅ 优先策略成功显示弹窗');
                return true;
            }
            
            const strategies = [
                () => findAndClickTriggerButtons(annotation, iframeDoc),
                () => showHiddenModals(iframeDoc),
                () => triggerModalEvents(annotation, iframeDoc),
                () => forceShowModalsByKeywords(annotation, iframeDoc)
            ];
            
            for (let i = 0; i < strategies.length; i++) {
                try {
                    console.log(`🔄 执行弹窗显示策略 ${i + 1}...`);
                    await strategies[i]();
                    await new Promise(resolve => setTimeout(resolve, 500)); // 等待动画完成
                    
                    // 检查是否成功显示了目标元素
                    const targetElement = await findTargetElement(annotation, iframeDoc);
                    if (targetElement && isElementVisible(targetElement)) {
                        console.log(`✅ 策略 ${i + 1} 成功显示弹窗`);
                        return true;
                    }
                } catch (error) {
                    console.warn(`策略 ${i + 1} 失败:`, error);
                }
            }
            
            return false;
        }
        
        // 根据选择器直接显示弹窗
        async function showModalBySelector(annotation, iframeDoc) {
            const smartSelector = annotation.targetInfo?.smartSelector || '';
            
            if (!smartSelector) {
                console.log('❌ 没有智能选择器信息');
                return false;
            }
            
            console.log('🎯 根据智能选择器查找弹窗:', smartSelector);
            
            // 从选择器中提取弹窗容器ID或类名
            // 例如: "div#plot-popup > div.popup-header" -> "plot-popup"
            const modalIdMatch = smartSelector.match(/#([a-zA-Z0-9_-]+)/);
            const modalClassMatch = smartSelector.match(/\.([a-zA-Z0-9_-]*(?:modal|popup|dialog|panel)[a-zA-Z0-9_-]*)/i);
            
            let modalContainer = null;
            
            // 策略1: 通过ID直接查找弹窗
            if (modalIdMatch) {
                const modalId = modalIdMatch[1];
                modalContainer = iframeDoc.getElementById(modalId);
                if (modalContainer) {
                    console.log('🎯 通过ID找到弹窗容器:', modalId);
                } else {
                    console.log('❌ 未找到ID为', modalId, '的元素');
                }
            }
            
            // 策略2: 通过类名查找弹窗
            if (!modalContainer && modalClassMatch) {
                const modalClass = modalClassMatch[1];
                const candidates = iframeDoc.querySelectorAll(`.${modalClass}`);
                if (candidates.length > 0) {
                    modalContainer = candidates[0];
                    console.log('🎯 通过类名找到弹窗容器:', modalClass);
                }
            }
            
            // 策略3: 从选择器路径中推断弹窗容器
            if (!modalContainer) {
                const selectorParts = smartSelector.split(' > ');
                for (let i = 0; i < selectorParts.length - 1; i++) {
                    const part = selectorParts[i].trim();
                    
                    // 检查是否包含弹窗关键词
                    const isModalPart = [
                        'popup', 'modal', 'dialog', 'panel', 'overlay'
                    ].some(keyword => part.toLowerCase().includes(keyword));
                    
                    if (isModalPart) {
                        try {
                            modalContainer = iframeDoc.querySelector(part);
                            if (modalContainer) {
                                console.log('🎯 通过选择器路径找到弹窗容器:', part);
                                break;
                            }
                        } catch (e) {
                            console.warn('选择器查找失败:', part, e);
                        }
                    }
                }
            }
            
            if (modalContainer) {
                console.log('📋 弹窗容器信息:', {
                    tagName: modalContainer.tagName,
                    id: modalContainer.id,
                    className: modalContainer.className,
                    currentDisplay: modalContainer.style.display,
                    currentVisibility: modalContainer.style.visibility
                });
                
                // 显示弹窗
                const showResult = await showModal(modalContainer, iframeDoc);
                
                if (showResult) {
                    // 等待弹窗显示完成
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // 验证目标元素是否现在可见
                    const targetElement = await findTargetElement(annotation, iframeDoc);
                    if (targetElement && isElementVisible(targetElement)) {
                        console.log('✅ 弹窗显示成功，目标元素现在可见');
                        return true;
                    } else {
                        console.log('⚠️ 弹窗已显示，但目标元素仍不可见');
                    }
                }
            } else {
                console.log('❌ 无法从选择器中确定弹窗容器');
                
                // 强化查找策略：尝试更多的查找方法
                console.log('🔍 使用强化查找策略...');
                const enhancedResult = await enhancedModalSearch(annotation, iframeDoc);
                if (enhancedResult) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 强化弹窗查找策略
        async function enhancedModalSearch(annotation, iframeDoc) {
            console.log('🔍 开始强化弹窗查找...');
            
            const smartSelector = annotation.targetInfo?.smartSelector || '';
            const textContent = annotation.targetInfo?.textContent || '';
            
            // 策略1: 深度DOM查找 - 查找所有可能的弹窗容器
            console.log('📋 策略1: 深度DOM查找所有弹窗容器...');
            const allPossibleModals = iframeDoc.querySelectorAll(`
                div[id*="popup"], div[id*="modal"], div[id*="dialog"],
                div[class*="popup"], div[class*="modal"], div[class*="dialog"],
                div[class*="overlay"], div[class*="panel"], 
                .plot-popup, .plot-info-popup, .info-popup,
                [role="dialog"], [aria-modal="true"]
            `);
            
            console.log(`📊 找到 ${allPossibleModals.length} 个可能的弹窗容器`);
            
            for (let modal of allPossibleModals) {
                console.log('🔍 检查弹窗容器:', {
                    tagName: modal.tagName,
                    id: modal.id,
                    className: modal.className,
                    display: modal.style.display,
                    visibility: modal.style.visibility
                });
                
                // 检查这个容器是否包含我们要找的元素
                const headerInModal = modal.querySelector('.popup-header');
                if (headerInModal) {
                    console.log('🎯 在弹窗中找到头部元素:', headerInModal);
                    
                    // 显示这个弹窗
                    const showResult = await showModal(modal, iframeDoc);
                    if (showResult) {
                        // 验证目标元素是否现在可见
                        const targetElement = await findTargetElement(annotation, iframeDoc);
                        if (targetElement && isElementVisible(targetElement)) {
                            console.log('✅ 强化查找成功，目标元素现在可见');
                            return true;
                        }
                    }
                }
            }
            
            // 策略2: 文本内容匹配查找
            console.log('📋 策略2: 基于文本内容查找...');
            if (textContent && textContent.length > 5) {
                const textSearchKeywords = textContent.split(/\s+/).filter(word => word.length > 2);
                
                for (let keyword of textSearchKeywords) {
                    if (keyword.includes('蔬菜') || keyword.includes('地块') || keyword.includes('信息')) {
                        console.log('🔍 搜索关键词:', keyword);
                        
                        // 查找包含这些关键词的元素
                        const allElements = iframeDoc.querySelectorAll('*');
                        for (let element of allElements) {
                            if (element.textContent && element.textContent.includes(keyword)) {
                                // 向上查找可能的弹窗容器
                                const modalContainer = findParentModal(element);
                                if (modalContainer) {
                                    console.log('🎯 通过文本内容找到弹窗:', modalContainer);
                                    const showResult = await showModal(modalContainer, iframeDoc);
                                    if (showResult) {
                                        const targetElement = await findTargetElement(annotation, iframeDoc);
                                        if (targetElement && isElementVisible(targetElement)) {
                                            console.log('✅ 文本匹配查找成功');
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // 策略3: 模糊选择器匹配
            console.log('📋 策略3: 模糊选择器匹配...');
            if (smartSelector) {
                // 提取选择器中的关键部分进行模糊匹配
                const selectorParts = smartSelector.split(/[>\s]+/).map(part => part.trim());
                
                for (let part of selectorParts) {
                    if (part.includes('popup') || part.includes('header') || part.includes('plot')) {
                        console.log('🔍 尝试模糊选择器:', part);
                        
                        try {
                            // 移除精确的伪类选择器，进行模糊匹配
                            const fuzzySelector = part.replace(/:\w+(-\w+)?\([^)]*\)/g, '');
                            const elements = iframeDoc.querySelectorAll(`[class*="${fuzzySelector.replace(/[.#]/g, '')}"], [id*="${fuzzySelector.replace(/[.#]/g, '')}"]`);
                            
                            for (let element of elements) {
                                const modalContainer = element.closest('[class*="popup"], [class*="modal"], [id*="popup"], [id*="modal"]') || findParentModal(element);
                                if (modalContainer) {
                                    console.log('🎯 通过模糊匹配找到弹窗:', modalContainer);
                                    const showResult = await showModal(modalContainer, iframeDoc);
                                    if (showResult) {
                                        const targetElement = await findTargetElement(annotation, iframeDoc);
                                        if (targetElement && isElementVisible(targetElement)) {
                                            console.log('✅ 模糊匹配查找成功');
                                            return true;
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('模糊选择器匹配失败:', part, e);
                        }
                    }
                }
            }
            
            // 策略4: 强制显示所有隐藏的可能弹窗
            console.log('📋 策略4: 强制显示所有可能的隐藏弹窗...');
            const hiddenElements = iframeDoc.querySelectorAll(`
                div[style*="display: none"], div[style*="visibility: hidden"],
                .hidden, .hide, .d-none, [aria-hidden="true"]
            `);
            
            for (let element of hiddenElements) {
                // 检查是否看起来像弹窗
                const couldBeModal = (
                    element.id.toLowerCase().includes('popup') ||
                    element.id.toLowerCase().includes('modal') ||
                    element.className.toLowerCase().includes('popup') ||
                    element.className.toLowerCase().includes('modal') ||
                    element.querySelector('.popup-header, .modal-header, .dialog-header')
                );
                
                if (couldBeModal) {
                    console.log('🔍 发现隐藏的可能弹窗:', element);
                    const showResult = await showModal(element, iframeDoc);
                    if (showResult) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                        const targetElement = await findTargetElement(annotation, iframeDoc);
                        if (targetElement && isElementVisible(targetElement)) {
                            console.log('✅ 隐藏弹窗显示成功');
                            return true;
                        }
                    }
                }
            }
            
            console.log('❌ 所有强化查找策略都失败了');
            return false;
        }
        
        // 查找并点击触发按钮
        function findAndClickTriggerButtons(annotation, iframeDoc) {
            const annotationText = annotation.name || annotation.targetInfo?.textContent || '';
            
            // 根据批注内容智能查找可能的触发按钮
            const possibleTriggers = [
                // 通用触发器选择器
                '[data-toggle="modal"]',
                '[data-target*="modal"]',
                '.modal-trigger',
                '.popup-trigger',
                '.detail-btn',
                '.info-btn',
                '.settings-btn',
                
                // 农业系统特定
                '.crop-detail-btn',
                '.device-info-btn',
                '.plot-info-btn'
            ];
            
            // 基于文本内容的按钮查找
            const textKeywords = [
                annotationText,
                '详情', '信息', '设置', '查看', '显示', '打开',
                '地块', '作物', '设备', '气象', '分析'
            ];
            
            possibleTriggers.forEach(selector => {
                try {
                    const buttons = iframeDoc.querySelectorAll(selector);
                    buttons.forEach(button => {
                        if (isElementVisible(button)) {
                            console.log('🖱️ 点击触发按钮:', selector);
                            button.click();
                        }
                    });
                } catch (e) {
                    console.warn('点击触发按钮失败:', selector, e);
                }
            });
            
            // 查找包含关键词的按钮
            findButtonsByText(iframeDoc, textKeywords);
            
            // 特殊处理：如果是地块弹窗，尝试点击地图地块
            if (annotationText.includes('地块') || annotation.targetInfo?.smartSelector?.includes('plot-popup')) {
                console.log('🗺️ 检测到地块弹窗，尝试触发地块点击...');
                triggerPlotClick(iframeDoc);
            }
        }
        
        // 基于文本查找按钮
        function findButtonsByText(iframeDoc, keywords) {
            keywords.forEach(keyword => {
                if (!keyword || keyword.length < 2) return;
                
                try {
                    const allButtons = iframeDoc.querySelectorAll('button, input[type="button"], a[role="button"]');
                    
                    for (let button of allButtons) {
                        const text = button.textContent?.trim() || '';
                        const title = button.title || '';
                        const ariaLabel = button.getAttribute('aria-label') || '';
                        
                        if ((text.includes(keyword) || title.includes(keyword) || ariaLabel.includes(keyword)) 
                            && isElementVisible(button)) {
                            console.log('🖱️ 基于文本点击按钮:', keyword, text);
                            button.click();
                            return; // 找到就停止
                        }
                    }
                } catch (e) {
                    console.warn('文本按钮查找失败:', keyword, e);
                }
            });
        }
        
        // 显示隐藏的弹窗
        function showHiddenModals(iframeDoc) {
            const modalSelectors = [
                '.modal', '.dialog', '.popup', '.overlay', '.panel',
                '.detail-panel', '.info-panel', '.plot-popup',
                '[class*="modal"]', '[class*="popup"]', '[class*="dialog"]'
            ];
            
            modalSelectors.forEach(selector => {
                try {
                    const modals = iframeDoc.querySelectorAll(selector);
                    modals.forEach(modal => {
                        if (!isElementVisible(modal)) {
                            showModal(modal, iframeDoc);
                        }
                    });
                } catch (e) {
                    console.warn('显示隐藏弹窗失败:', selector, e);
                }
            });
        }
        
        // 触发弹窗相关事件
        function triggerModalEvents(annotation, iframeDoc) {
            const events = [
                'showModal', 'openDialog', 'displayPopup', 'showPanel',
                'showDetail', 'openInfo', 'toggleModal'
            ];
            
            events.forEach(eventName => {
                try {
                    const event = new iframeDoc.defaultView.CustomEvent(eventName, {
                        bubbles: true,
                        detail: { annotation: annotation }
                    });
                    iframeDoc.dispatchEvent(event);
                } catch (e) {
                    console.warn('触发事件失败:', eventName, e);
                }
            });
        }
        
        // 基于关键词强制显示弹窗
        function forceShowModalsByKeywords(annotation, iframeDoc) {
            const smartSelector = annotation.targetInfo?.smartSelector || '';
            const name = annotation.name || '';
            
            // 从选择器和名称中提取关键词
            const keywords = [
                ...smartSelector.split(/[.#\s>]+/).filter(k => k.length > 2),
                ...name.split(/[\s\-_]+/).filter(k => k.length > 2)
            ];
            
            keywords.forEach(keyword => {
                try {
                    // 查找包含关键词的隐藏元素
                    const elements = iframeDoc.querySelectorAll(`[class*="${keyword}"], [id*="${keyword}"]`);
                    elements.forEach(element => {
                        const className = element.className.toLowerCase();
                        const id = element.id.toLowerCase();
                        
                        // 如果看起来像弹窗容器
                        if (className.includes('modal') || className.includes('popup') || 
                            className.includes('dialog') || id.includes('modal') || 
                            id.includes('popup') || id.includes('dialog')) {
                            showModal(element, iframeDoc);
                        }
                    });
                } catch (e) {
                    console.warn('关键词弹窗显示失败:', keyword, e);
                }
            });
        }
        
        // 触发地块点击事件
        function triggerPlotClick(iframeDoc) {
            console.log('🗺️ 开始尝试触发地块点击...');
            
            // 策略1: 查找并点击地图上的地块元素
            const plotSelectors = [
                '.plot', '.crop-plot', '.field', '.land-plot', '.plot-layer',
                '[class*="plot"]', '[class*="field"]', '[class*="crop"]',
                'g[class*="plot"]', 'path[class*="plot"]', 'polygon[class*="plot"]',
                '.cesium-credit-logo', 'canvas'  // Cesium地图元素
            ];
            
            let clickSuccess = false;
            
            plotSelectors.forEach(selector => {
                if (clickSuccess) return;
                
                try {
                    const elements = iframeDoc.querySelectorAll(selector);
                    if (elements.length > 0) {
                        // 点击第一个可见的元素
                        for (let element of elements) {
                            if (isElementVisible(element)) {
                                console.log('🎯 点击地块元素:', {
                                    selector: selector,
                                    tagName: element.tagName,
                                    className: element.className
                                });
                                
                                // 模拟点击事件
                                element.click();
                                clickSuccess = true;
                                break;
                            }
                        }
                    }
                } catch (e) {
                    console.warn('地块元素点击失败:', selector, e);
                }
            });
            
            // 策略2: 如果没有找到地块元素，尝试点击地图容器
            if (!clickSuccess) {
                console.log('🗺️ 未找到地块元素，尝试点击地图容器...');
                
                const mapSelectors = [
                    '#cesiumContainer', '.cesium-viewer', '.map-container',
                    '#map', '.map', 'canvas', '.leaflet-container'
                ];
                
                mapSelectors.forEach(selector => {
                    if (clickSuccess) return;
                    
                    try {
                        const mapElement = iframeDoc.querySelector(selector);
                        if (mapElement && isElementVisible(mapElement)) {
                            console.log('🎯 点击地图容器:', selector);
                            
                            // 在地图中心位置模拟点击
                            const rect = mapElement.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            
                            const clickEvent = new iframeDoc.defaultView.MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: iframeDoc.defaultView,
                                clientX: centerX,
                                clientY: centerY
                            });
                            mapElement.dispatchEvent(clickEvent);
                            clickSuccess = true;
                        }
                    } catch (e) {
                        console.warn('地图容器点击失败:', selector, e);
                    }
                });
            }
            
            // 不再强制创建弹窗，必须找到现有弹窗
            if (!clickSuccess) {
                console.log('⚠️ 所有地块点击策略失败，弹窗可能需要其他方式触发');
            }
            
            return clickSuccess;
        }
        


        // 改进的元素选择和高亮系统
        function enhancedHighlightElement(annotation) {
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) {
                console.warn('无法访问iframe内容');
                return false;
            }
            
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (!iframeDoc) {
                console.warn('无法访问iframe文档');
                return false;
            }
            
            let targetElement = null;
            
            // 策略1: 使用智能选择器
            if (annotation.targetInfo?.smartSelector) {
                try {
                    targetElement = iframeDoc.querySelector(annotation.targetInfo.smartSelector);
                    if (targetElement) {
                        console.log('✅ 智能选择器匹配成功');
                    }
                } catch (e) {
                    console.warn('❌ 智能选择器失败:', e);
                }
            }
            
            // 策略2: 使用元素指纹匹配
            if (!targetElement && annotation.targetInfo?.elementFingerprint) {
                targetElement = findElementByFingerprint(annotation.targetInfo.elementFingerprint, iframeDoc);
                if (targetElement) {
                    console.log('✅ 元素指纹匹配成功');
                }
            }
            
            // 策略3: 文本内容匹配
            if (!targetElement && annotation.targetInfo?.textContent) {
                const textContent = annotation.targetInfo.textContent.trim();
                if (textContent) {
                    const allElements = iframeDoc.querySelectorAll('*');
                    for (let element of allElements) {
                        if (element.textContent?.trim() === textContent || 
                            element.textContent?.trim().includes(textContent.substring(0, 20))) {
                            targetElement = element;
                            console.log('✅ 文本内容匹配成功');
                            break;
                        }
                    }
                }
            }
            
            // 策略4: 备用选择器
            if (!targetElement && annotation.targetInfo?.fallbackSelector) {
                try {
                    const candidates = iframeDoc.querySelectorAll(annotation.targetInfo.fallbackSelector);
                    if (candidates.length === 1) {
                        targetElement = candidates[0];
                        console.log('✅ 备用选择器匹配成功');
                    } else if (candidates.length > 1 && annotation.targetInfo.textContent) {
                        // 多个候选者时，根据文本内容进一步筛选
                        targetElement = Array.from(candidates).find(el => 
                            el.textContent?.trim().includes(annotation.targetInfo.textContent.substring(0, 20))
                        );
                        if (targetElement) {
                            console.log('✅ 备用选择器+文本筛选匹配成功');
                        }
                    }
                } catch (e) {
                    console.warn('❌ 备用选择器失败:', e);
                }
            }
            
            if (targetElement) {
                // 清除之前的高亮
                clearEnhancedHighlights();
                
                // 添加增强的高亮效果
                targetElement.style.outline = '3px solid #00a8ff';
                targetElement.style.outlineOffset = '2px';
                targetElement.style.backgroundColor = 'rgba(0, 168, 255, 0.1)';
                targetElement.style.boxShadow = '0 0 10px rgba(0, 168, 255, 0.5)';
                targetElement.setAttribute('data-enhanced-highlight', 'true');
                
                // 添加脉搏动画效果
                targetElement.style.animation = 'pulse-highlight 2s ease-in-out 3';
                
                // 滚动到视图
                targetElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center',
                    inline: 'center' 
                });
                
                console.log('🎯 成功高亮元素:', {
                    tagName: targetElement.tagName,
                    className: targetElement.className,
                    textContent: targetElement.textContent?.substring(0, 50)
                });
                
                return true;
            } else {
                console.warn('❌ 所有匹配策略都失败了');
                return false;
            }
        }
        
        // 清除增强高亮效果
        function clearEnhancedHighlights() {
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) return;
            
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (!iframeDoc) return;
            
            const highlightedElements = iframeDoc.querySelectorAll('[data-enhanced-highlight="true"]');
            highlightedElements.forEach(el => {
                el.style.outline = '';
                el.style.outlineOffset = '';
                el.style.backgroundColor = '';
                el.style.boxShadow = '';
                el.style.animation = '';
                el.removeAttribute('data-enhanced-highlight');
            });
        }
        
        // 添加CSS动画到iframe
        function addHighlightAnimationToIframe() {
            const iframe = document.getElementById('embeddedFrame');
            if (!iframe || !iframe.contentWindow) return;
            
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (!iframeDoc) return;
            
            // 检查是否已经添加过样式
            if (iframeDoc.getElementById('highlight-animation-styles')) return;
            
            const style = iframeDoc.createElement('style');
            style.id = 'highlight-animation-styles';
            style.textContent = `
                @keyframes pulse-highlight {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.02); }
                    100% { transform: scale(1); }
                }
            `;
            iframeDoc.head.appendChild(style);
        }

        // 页面加载完成后初始化
        window.addEventListener('load', async function() {
            console.log('窗口加载完成，开始初始化页面');
            await initializePage();
            
            // 添加高亮动画样式
            setTimeout(() => {
                addHighlightAnimationToIframe();
            }, 1000);
            
            // 强制刷新元素清单
            setTimeout(() => {
                console.log('强制刷新元素清单');
                updateElementList();
            }, 3000);
        });
    </script>
</body>
</html>



